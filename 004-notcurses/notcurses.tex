% arara: xelatex: {shell: true}
% arara: biber
% arara: makeglossaries
% arara: xelatex: {shell: true}
% arara: xelatex: {shell: true}
% arara: xelatex: {shell: true}
\documentclass[letterpaper,10pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{newfloat}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}
%\usepackage{draftwatermark}
\usepackage{fancyhdr}
\usepackage{makecell}
\usepackage{wrapfig}
\usepackage{parskip}
\usepackage[section]{placeins}
\usepackage{epigraph}
%\usepackage{sourcecodepro}
\usepackage{fontspec}
\usepackage[toc,nonumberlist,xindy]{glossaries}
\usepackage{xelatexemoji}
\usepackage{relsize}
%\setmonofont[Scale=0.7]{Source Code Pro}
\setmonofont[Scale=0.8]{Unifont}
\defaultfontfeatures{Ligatures=TeX}
\usepackage[table]{xcolor}
%\usepackage{pdfpages}
\usepackage[titletoc,title]{appendix}
\usepackage{minted}
\usepackage{xeCJK}
\usepackage{tipa}
\usepackage{polyglossia}
\usepackage{arabxetex}
\setmainlanguage{english}
\setotherlanguages{hebrew,french,bulgarian,russian,greek}
\newfontfamily\cyrillicfont[Script=Cyrillic]{Noto Sans}
\newfontfamily\hebrewfont[Scale=0.8,Script=Hebrew]{Cardo}
\newfontfamily\greekfont{Noto Sans}
\definecolor{dsscawpurp}{HTML}{b079b0}
\definecolor{dsscawpurpcap}{HTML}{6c286c}
\usepackage[font={color=dsscawpurpcap},labelfont={sc}]{caption}
\usepackage[backend=biber,
date=iso,
seconds=true,
style=numeric,
bibencoding=utf8,
]{biblatex}

\tracinglostchars=2

%\SetWatermarkText{DRAFT}
%\SetWatermarkScale{1}

\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  pdftitle={Hacking the Planet with Notcurses},
}

\addbibresource{\jobname.bib}
\usemintedstyle{friendly}
\newenvironment{denseitemize}{
  \begin{itemize}
      \setlength{\itemsep}{0pt}
}{
  \end{itemize}
}
% An attractive 'C++'
\newcommand\CC{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\relsize{-3}{\textbf{+}}}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\relsize{-3}{\textbf{+}}}\hspace{.2em}}

\pagestyle{fancy}
\rhead{
  \includegraphics[height=\fontcharht\font`\D,keepaspectratio=true]{../dsscaw-hdr.pdf}
  \textcolor{dsscawpurp}{DSSCAW Technical Report \#004}
}

\title{Hacking the Planet (with Notcurses)\\
A Guide to TUIs and Character Graphics
}
\author{Nick Black, Consulting Scientist\\
\texttt{nickblack@linux.com}
}

\makeglossaries
\setglossarypreamble{When possible, I have followed the definitions of
  RFC 2978\cite{rfc2978} and the Glossary of Unicode Terms\cite{unicodeglossary}.}
\loadglsentries{glossary}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\includepdf{media/frontcover.pdf}
\date{March 24, 2020}
\maketitle
\date{}
\vspace{1in}
\begin{center}
\includegraphics[width=.75\linewidth]{htp-with-notcurses.png}
\end{center}
\thispagestyle{empty}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\pagenumbering{roman}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace*{1.25in}
\begin{figure}[!htb]
\centering
\includegraphics[width=1\linewidth]{media/ibm3279.jpg}
\caption[]{A programmer at her IBM 3279 2A \textit{(source: Jonathan Schilling under CCASA4)}.}
\end{figure}
\clearpage
\vspace*{1in}
\begin{center}
  \textit{For T.\ S.\ Eliot, il miglior fabbro.} \\
  \vspace{.25in}
  \textit{For Jeanette Martin, for exhortations to go H.A.M. \\
  \vspace{.25in}
  For Jim Greenlee, for speaking rigor to my programming.\\
  \vspace{.25in}
    For Prof.\ Hyesoon Kim, for introducing me to the glorious world
    inside the die.\\
  \vspace{.25in}
    For Prof.\ Richard Vuduc, for demonstrating serenity in brilliance, and kindness in dominance.\\}
  \vspace{1in}\ldots but mostly for Emily.
\end{center}
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
%\vfill
%\begin{center}
%\includegraphics[width=1\linewidth]{media/widechars.png}
%\end{center}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{section}{\listfigurename}
\listoffigures
\addcontentsline{toc}{section}{List of Listings}
\listoflistings
\addcontentsline{toc}{section}{\listtablename}
\listoftables
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\addcontentsline{toc}{section}{Foreward}
\section*{Foreward}
Hacking the Planet with Notcurses: A Guide to Character Graphics and TUIs.
Copyright © 2020 Nick Black.
ISBN: 9798620069491

This edition corresponds to version 1.2.4 of the Notcurses library, released
2020-03-24. Notcurses can be downloaded from
\url{https://github.com/dankamongmen/notcurses}. This document can be
downloaded from~\url{https://nick-black.com/htp-notcurses.pdf}.

Licensed under the Apache License, Version 2.0 (the ``License''); you may not
use this document except in compliance with the License. You may obtain a copy
of the License at \url{http://www.apache.org/licenses/LICENSE-2.0}.

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ``AS IS'' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

The entirety of this work is Free Documentation, written for love and released
to instruct. If you'd like to show thanks for my efforts, I encourage a donation to
the~\href{https://www.thefire.org/}{Foundation for Individual Rights in Education} (\url{https://www.thefire.org/}).
Alternatively, buy the paperback!

This work was prepared on a Debian Unstable Linux workstation and an Arch Linux laptop,
using Vim, \XeLaTeX, and the GIMP. A FreeBSD 12 machine was emulated with QEMU.

Tetris © The Tetris Company, LLC.
\textit{Hackers (1995)} © United Artists Pictures.
\textit{House of Leaves (2000)} © Penguin Random House.
``Ruins with Rain'' © Mark Ferrari/Living Worlds.
``Final Fantasy'' © Square Enix Co Ltd.
``Super Mario Bros.'' © Nintendo of America.
``Ninja Gaiden'' © Koei Tecmo America.
``Street Fighter II'' and ``Mega Man 2'' © Capcom of America.
Please don't sue me.

\addcontentsline{toc}{subsection}{¡Peligro!}
\subsection*{¡Peligro!}

The code written for this book attempts to minimize use of vertical space
(fewer pages → cheaper book) without eliding error checking (or crossing into
the realms of the grotesque). Error handling is a fundamental slog of C
programming, one that inevitably complicates reliable applications.

These listings cannot be considered examples of good general style\ldots but they \textit{do} get the job done.

Three irregular idioms show up frequently:

\begin{denseitemize}
\item{Use of |= to collect non-zero return values from each of a series of
      non-interdependent function calls.}
\item{Right-hand-side conditionals fed into |=, e.g. \texttt{r |= (printf("dank") < 0);}.}
\item{Extensive use of ||'s short-circuiting property.}
\end{denseitemize}

\addcontentsline{toc}{subsection}{Errata}
\subsection*{Errata}
A list of errata for this First Edition is kept at
\begin{center}
\url{https://nick-black.com/dankwiki/index.php/Hacking\_The\_Planet!\_with\_Notcurses}
\end{center}
Please contact me with corrections, either via mail at \href{mailto:nickblack@linux.com}{nickblack@linux.com},
or via PR on
\begin{center}
\url{https://github.com/dirty-south-supercomputing/technicalreports}
\end{center}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{arabic}

\epigraph{Our fine arts were developed, their types and uses were established, in times
very different from the present, by men whose power of action upon things was
insignificant in comparison with ours. But the amazing growth of our
techniques, the adaptability and precision they have attained, the ideas and
habits they are creating, make it a certainty that profound changes are
impending in the ancient craft of the Beautiful.}{Paul Valéry}
\section{Introduction}

I implemented Notcurses in the winter of 2019 after having a few patches
rejected from NCURSES. The first commit was pushed 2019-11-16. It proved to
be seductive as hell, and it was only with difficulty that I tore myself away
following three months of hard work. I started writing this manuscript
2020-02-12, following the 1.1.8 release. By that time, Notcurses subsumed large
chunks of NCURSES, adding a great deal more. The project had three major goals:

\begin{denseitemize}
\item to provide NCURSES-like functionality with 24-bit color, safety in the
    presence of multithreading, and full Unicode support,
\item to reduce the amount of boilerplate code necessary for the UIs of my
    TUI applications, including \textit{growlight} and \textit{omphalos}, and
\item to portably facilitate the most vivid character graphics possible.
\end{denseitemize}

Many people asked how such a thing was useful. My usual response was that
numerous devices don't present a bitmap interface, that X11 GUIs run remotely
over SSH are effectively unusable beyond a local network, that plenty of
machines don't have a GUI environment installed, that there are obvious
applications for large outdoor displays, and that Sixel isn't well-supported
across different terminal emulators. It seems impossible in an age of
gigatransistor graphics cards, but the text environment still presents
perceivably less latency than most GUI toolkits. That I was able to remove
thousands of lines of NCURSES code from my applications was a nice side
benefit.

In truth, the main reasons were that it was fun, and I wanted to see how far
I could push it.

As I write this, Notcurses is present in Arch's AUR, and is awaiting promotion
from the Debian Incoming queue. Written as a C core, it enjoys \CC, Python, and
Rust wrappers. I have submitted it as a backend to NEStopia and RetroArch, and
intend to integrate it into Mesa as an OpenGL backend. So long as one can live
with the limited resolution available when a screen is divided into rectangular
cells, it can handle any graphics thrown at it. I hope to see it displace
NCURSES as the go-to character graphics library for new applications (there is
little value in porting existing applications to Notcurses, since an unchanged
application wouldn't take advantage of its advanced features).

While the X/Open Curses specification is unlikely to ever go away (nor should
it, as a lowest-common-denominator interface to devices Notcurses is unlikely
to ever support), I believe Notcurses to present a superior interface and
implementation for modern TUI applications.

The console ain't dead! Hack on, hax0rs.

\vfill

\begin{flushright}
  \textit{---February--March 2020, Atlanta}
\end{flushright}

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\vfill
\begin{figure}
\centering
\includegraphics[width=.65\linewidth]{media/chunli-box-front.png}
\caption[]{A rendered scene from the ``chunli'' demo (see Chapter~\ref{sec:ncdemo}),
  using some of the advanced capabilities of Notcurses. The Chun-Li sprite has
  been loaded from a transparent PNG (Chapter~\ref{sec:libav}) atop boxes
  (Chapter~\ref{sec:boxes}) drawn using Unicode (Chapter~\ref{section:unicode})
  and linear interpolations (Chapter~\ref{sec:lerps}). Along the top is a
  menu (Chapter~\ref{sec:menus}) and an independent plane (Chapter~\ref{sec:planes});
  both can be controlled with mice (Chapter~\ref{sec:input}). In the center,
  the desktop can be seen through the transparent background of the terminal.}
\end{figure}
\vfill
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Right, what's all this, then?}
\label{sec:start}
\epigraph{A terminal is at the end of an electric wire, a shell is the home of a turtle, tty is a strange abbreviation and a console is a kind of cabinet.}{Gilles Leblanc\cite{gillesSO}}
Character graphics, aka text mode, aka the display side of a terminal, is
visualization that works with fonts rather than a pixel framebuffer\footnote{``Contones'', as raster graphics are known to printers.}
or a vector canvas\footnote{Nothing keeps you from implementing character graphics
with pixels or vectors, of course.}. There is furthermore an expectation that
this font is a fixed-width one---that all rendered glyphs are integer multiples
of some narrowest non-trivial glyph.

Given the same display hardware,

\begin{denseitemize}
\item{Character graphics are usually strictly less powerful than pure raster graphics, and}
\item{their lower effective resolution typically implies lower bandwidth requirements.}
\end{denseitemize}

A TUI (text user interface) is a holistic model, view, and controller implemented
using character graphics. TUIs, like WIMP\footnote{Windows, icons, menus, pointers, a paradigm so pervasive that
the industry collectively treasures a Wiemarian\cite{thirdreich} memory of Xerox PARC's noble
engineers stabbed in the back by management (not unlike the Oatmeal-fostered\cite{fuckoatmeal}
myopia regarding Edison and Tesla. I'll take Thomas Alva over Matthew Inman any
day). It too often goes unmentioned that the Alto and Star were as unusable as they were visionary\cite{lightningdealers}.
This is of course still superior to Java, which isn't even visionary.} GUIs,
freely move the cursor around their rectilinear display, as opposed to
line-oriented CLIs and their ineluctable marches through the scrolling region.

Given the same interactive task,\footnote{These relations are not
fundamental, but emerge from the grim meathook realities of GUI toolkits.}

\begin{denseitemize}
\item{A TUI implementation is almost certainly a smaller memory and disk footprint than a GUI,}
\item{a good TUI implementation might introduce less latency, and}
\item{a properly-done TUI implementation can often be significantly more portable.}
\end{denseitemize}

It can also be a big pile of character graphics garbage. A TUI offers
less resolution, less flexibility, and (due to monospaced fonts) less total
text space. Applications must be carefully designed for the limitations of
a dynamic textual environment.

For over two decades, NCURSES (a free software implementation of the X/Open Curses\cite{cursesosi}
specification, plus extensions\cite{ncursesfaq}) has been a ubiquitous go-to for implementing
TUIs. Maintainter (and author, in large part) Thomas E.\ Dickey
exemplifies conservative and fastidious stewardship. Perfectly lovely TUIs can
be built using NCURSES (as seen in Figure~\ref{fig:ncurses-tuis}), but it \textit{does}
have its origins in the 8-bit era, and shows its age.

\begin{figure}[!hbtp]
  \centering
    \includegraphics[width=.4\linewidth]{media/tui-ncmpcpp.png}
    \hfill
    \includegraphics[width=.4\linewidth]{media/tui-omphalos.png}
    \caption[NCURSES TUIs: Ncmpcpp and Omphalos.]
    {Left: \texttt{ncmpcpp}, a \CC application
      that has driven my Music Player Daemon since 2008 or so.
      Right: \texttt{omphalos}, a C network exploration tool
      written using NCURSES in its extended mode.}
  \label{fig:ncurses-tuis}
\end{figure}

\begin{figure}[!htb] \centering
    \includegraphics[width=.4\linewidth]{media/tui-mapscii.png}
    \hfill
    \includegraphics[width=.4\linewidth]{media/tui-growlight.png}
    \caption[Non-NCURSES TUIs: Mapscii and Growlight.]{Left: \texttt{mapscii}, a
    node.js application, blew my mind when I first saw it. The high resolution
    is achieved by using Braille characters, trading away some color control.
    Right: \texttt{growlight}, a disk manager, began life as an NCURSES C
    program, but was ported to Notcurses in 2019.}
  \label{fig:notncurses-tuis}
\end{figure}

Implementing a TUI will usually require, at a minimum:
\begin{denseitemize}
\item{Receiving input from user devices, including keyboards and mice,}
\item{some manner of user configuration flow (menus, etc.),}
\item{watching for some other event(s) from the system, and},
\item{juggling these various components without wastefully polling, nor
       introducing undue latency, and enforcing safe synchronized access to
       the graphics interface.}
\end{denseitemize}

Perhaps most terrifyingly, it will require user interface design. Notcurses
attempts to assist with this by providing numerous ready-made widgets.

\pagebreak

This text has two goals:
\begin{denseitemize}
\item{To provide a firm footing for design and implementation of character
    graphics and TUIs, elucidating the dimensions of design, along with difficulties
    to avoid, and}
\item{to serve as ``narrative reference'' for my Notcurses
      library, and as a starting place for newcomers.}
\end{denseitemize}

\begin{figure}[!htb]
\centering \includegraphics[width=.5\linewidth]{media/emacs-xerox.jpg}
  \caption{Put not your trust in hackers making a fetish of Xerox PARC.}
  \label{fig:xeroxemacs}
\end{figure}

Cell graphics are primarily the realm of \textit{terminals}, which for the
purposes of this book encompass any means by which input devices act to drive
some process generating glyph-based output to a display. This includes hardware
terminals (inputs integrated with displays, connected to a computer as a unit),
operating system consoles (text-mode interfaces operating with the graphics
engine directly connected to the terminal driver), terminal multiplexers (tools
like \texttt{screen}, \texttt{tmux}, and \texttt{mosh}, providing a
memory-persistent virtual terminal with which other terminals can interact),
and terminal emulators (applications which present a virtual terminal atop the
shared input and raster output methods of a graphical user environment).
There's some vagueness and variety involved with these terms.

At its heart, a terminal is a line discipline plus two buffers: an input buffer
to collect user-generated events (possibly from multiple devices), and an
output buffer to be processed and displayed. The buffers can be modeled as byte
streams, mutating the output at the time of their display (in contrast to e.g.\
a framebuffer, where the entirety of the screen is present at any given time).
The earliest terminals were electromechanical teletypes, reproducing their
input as line-based print on paper. These gave rise to ``dumb terminals''
(cathode-ray displays with a scrolling rectilinear output area). ``Smart
terminals'' followed, with the ability to move freely within their display
area, and also to extract and act upon ``control codes'' embedded in the output
stream. The text modes of the first video cards were designed around the
capabilities of these smart terminals. This brings us to the present, wherein
high-powered LED displays have their pixels summoned up and ordered into
formations suitable for the reconstruction of 1970s technology (a history of
terminals is presented in Appendix~\ref{sec:terminals}).

The machine on which I'm preparing this \XeLaTeX\ contains a
TU104 GPU consisting of over thirteen billion 12nm-process transistors,
rendering its output to a 3440x1440 (almost five megapixel) display. Deep
within its silicon heart remains a VGA 80x25 text mode engine\cite{vga}, inherited
largely unchanged from the EGA, the CGA\footnote{The Color Graphics Adapter was
unmitigated trash, but you could do some crazy things with it. People were
still finding things out this decade\cite{cga1024}, resulting in the
nigh-obscene ``8088 MPH'' demo that won Revision 2015\cite{revision2015}.},
the IBM Monochrome Display Adapter\footnote{The
history of video display standards since 1981's MDA is a story of imprecision,
dashed hopes, and idle dreams. Good luck finding authoritative references
for anything beyond \texttt{int 10h} real mode operation prior to version 1.0
of the SuperVGA VESA BIOS Extension\cite{videostandards}, released 1989-10-01\cite{vesa}.},
and before that smart terminals\footnote{As early as 1971, the block-oriented
IBM 3277 Model 2 ``green screen'' shipped with 80x24.}.


I mainly use this modern marvel to drive terminal emulators of 80 columns.

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Using direct mode with standard I\/O}
\label{sec:direct}
\epigraph{Unscrew the locks from the doors!\\Unscrew the doors themselves from their jambs!}{Walt Whitman, \textit{Song of Myself}}
Many tools don't intend to be full-screen TUI applications, but instead
implement that purest of UNIX interfaces: newline-delimited text, oblivious
to screen geometry, capable of being fed as input to other, similar programs.
For such tools, the full Notcurses capabilities are neither necessary nor
desirable. These programs are typically non-interactive: humans might peruse
their outputs and prepare their inputs, but they effectively run as a batch
task.

 Such tools might still want to colorize and otherwise style their output, at
least when being output to a terminal. This can be accomplished using the
\texttt{ncdirect} subset of Notcurses, and is known as \textit{direct mode}. Direct
mode functionality should not usually be mixed with other Notcurses calls.
Unlike full Notcurses, there is no explicit rendering step in direct mode, and
it is intended to be mixed among other use of standard I/O. Essentially, direct
mode ``styles your \texttt{printf()}s.'' Similarly to full Notcurses, direct mode
requires a valid and correct terminfo database entry, supplied via either the
\texttt{termtype} parameter to \texttt{ncdirect\_init()} or the \texttt{TERM} environment
variable. It does \textit{not}, however, require any particular encoding or
other locale properties\cite{setlocale} (full Notcurses requires a
properly-configured ASCII or UTF-8 locale).

Enter direct mode via a call to \texttt{ncdirect\_init()} with a successful
return of a non-\texttt{NULL} pointer to \texttt{struct ncdirect}. It is
typical to invoke this function as \texttt{ncdirect\_init(NULL, stdout)}. In this case, the terminal type must be present in the
\texttt{TERM} environment variable (this should have been done by the
terminal). The buffering and blocking status of \texttt{fp} will not be
changed. \texttt{NULL} is returned for any number of possible errors.
Otherwise, the \texttt{struct ncdirect} is ready to go, and should be cleaned
up with \texttt{ncdirect\_stop()}.

\begin{listing}[!htb]
\begin{minted}{C}
// Initialize a direct-mode notcurses context on the connected terminal at 'fp'. 'fp' must be a tty. You'll usually
// want stdout. Direct mode supportes a limited subset of notcurses routines which directly affect 'fp', and neither
// supports nor requires notcurses_render(). This can be used to add color and styling to text in the standard
// output paradigm. Returns NULL on error, including any failure initializing terminfo.
struct ncdirect* ncdirect_init(const char* termtype, FILE* fp);

// Release 'nc' and any associated resources. 0 on success, non-0 on failure.
int ncdirect_stop(struct ncdirect* nc);
\end{minted}
\caption{Initializing and stopping direct mode.}
\end{listing}

Between these two calls, inject stylizing control codes into the \texttt{FILE*} with
the \texttt{ncdirect} (the \texttt{stylebits} values are detailed in Chapter~\ref{sec:attribute}).
As detailed in Chapter~\ref{sec:channels}, the terminal has a ``default foreground color''
and ``default background color''. Return to these default colors with
\texttt{ncdirect\_fg\_default()} and \texttt{ncdirect\_bg\_default()}.

\begin{listing}[!htb]
\begin{minted}{C}
int ncdirect_bg_rgb8(struct ncdirect* n, unsigned r, unsigned g, unsigned b);
int ncdirect_fg_rgb8(struct ncdirect* n, unsigned r, unsigned g, unsigned b);
int ncdirect_fg(struct ncdirect* n, unsigned rgb);
int ncdirect_bg(struct ncdirect* n, unsigned rgb);
int ncdirect_styles_set(struct ncdirect* n, unsigned stylebits);
int ncdirect_styles_on(struct ncdirect* n, unsigned stylebits);
int ncdirect_styles_off(struct ncdirect* n, unsigned stylebits);
int ncdirect_clear(struct ncdirect* n);
int ncdirect_fg_default(struct ncdirect* n);
int ncdirect_bg_default(struct ncdirect* n);
\end{minted}
\caption{The \texttt{ncdirect} styling API.}
\end{listing}

Direct mode provides helpers for determining the terminal geometry.

\begin{listing}[!htb]
\begin{minted}{C}
int ncdirect_dim_x(const struct ncdirect* nc);
int ncdirect_dim_y(const struct ncdirect* nc);
\end{minted}
\caption{Geometry discovery with \texttt{ncdirect}.}
\end{listing}

Direct mode allows the cursor to be disabled, enabled, and moved in
two-dimensional space. Either \texttt{y} or \texttt{x} may be specified as -1
to maintain location on the associated axis.

\begin{listing}[!htb]
\begin{minted}{C}
int ncdirect_cursor_move_yx(struct ncdirect* n, int y, int x);
int ncdirect_cursor_enable(struct ncdirect* nc);
int ncdirect_cursor_disable(struct ncdirect* nc);
\end{minted}
\caption{Cursor management with \texttt{ncdirect}.}
\end{listing}

\subsection{Example: presenting \textit{\textcolor{blue}{House} of Leaves}}
Mark Z. Danielewski's experimental 2000 novel \textit{\textcolor{blue}{House} of Leaves}\cite{danielewski2000house} prints each
instance of the word \textcolor{blue}{house} in blue, even when it is a subword:

\begin{figure}[!htb]
\centering \includegraphics[width=.5\linewidth]{house-blue.png}
\caption[]{An excerpt from page 123 of \textit{\textcolor{blue}{House} of Leaves}.}
\label{fig:houseofleaves}
\end{figure}

We can easily write code to reproduce this effect for standard input and output.
Listing~\ref{list:holformatter} works as expected (see
Figure~\ref{fig:houseout}), but there are a few things worth noting about its
code. First, observe how much of the logic is devoted to checking and
propagating errors! Perhaps contrary to common expectation, reliable
code---especially when that code's primary effect is to write to
stdout---generally needs to check the results of e.g. \texttt{printf()} (what
happens if we're redirected to a file, and the disk is full?). A language
making use of exceptions would reduce if not eliminate this nonsense.

\begin{listing}[!htb]
\inputminted[]{C}{code/hol-formatter.c}
\caption{\texttt{hol-formatter.c}, a streaming formatter.}
\label{list:holformatter}
\end{listing}

\begin{figure}[!htb]
\centering \includegraphics[width=.75\linewidth]{hol-formatted.png}
\caption[\texttt{hol-formatter} as run on OCRd input.]{\texttt{hol-formatter} as run on our input. We use \texttt{tesseract} for OCR, with solid results.}
\label{fig:houseout}
\end{figure}

So long as we're dealing with either ASCII or UTF-8 input, our simple, old-skool
\texttt{tolower(3)} is satisfactory \textit{for this problem}. The key
observation is that UTF-8 encoded text can be compared for equality by
a structure-oblivious~\texttt{memcmp(3)}, as of course can ASCII.
Unless we need to color e.g.~\textcolor{blue}{\texttt{ℏöûⓈᴇ}} (maybe we should,
maybe we shouldn't) this is safe, simple, and sufficient. If we \textit{do}
wish to collapse distinct but by some measure similar EGCs, we should normalize
input as prescribed by Unicode Standard Annex \#15\cite{annex15}.

We don't switch from blue to some other specified color, because we don't know
the background color of the terminal. Some people, possibly aliens, don't favor
a dark terminal background. If the terminal background were white, and we had
just used e.g. \texttt{ncdirect\_fg(n, 0xffffff)}, text following
``\textcolor{blue}{house}'' would be invisible.

One might observe that a user with a blue background will have invisible
``\textcolor{blue}{house}'' text. This is a real issue, one lacking a perfect
solution\footnote{Applying \texttt{NCSTYLE\_STANDOUT} might or might not help.}.
It is not generally possible to discover the RGB values of the default colors.
I suppose all one can do is rest easy, serene in the belief that white
backgrounds are one thing, but people with chromatic backgrounds deserve
whatever happens to them.

\subsection{Example: colorizing a dumb game}
Imagine we've written the simple guessing game in Listing~\ref{list:guessgame}.

\begin{listing}[!htb]
\inputminted[]{C}{code/hilostdio.c}
\caption{\texttt{hilostdio.c}, a simple guessing game.}
\label{list:guessgame}
\end{listing}

The correct approach for a player is binary search, and for an $N$-bit
\texttt{long}, we expect to guess the number in no more than $N$ tries. Let's
color the output to indicate how bad of a guess was offered. We'll use red for
low guesses, blue for high guesses, and break the 256 shades of each (assuming
the other two components to be fixed) uniformly across the $N$ levels of
logarithmic distance\footnote{This would be a good place to employ \gls{gamma correction}.}.
If we wanted to do this (see Listing~\ref{list:hilodirect}) without direct use of RGB color,
we'd either need accept fewer shades, or be forced to reprogram the palette.

\begin{listing}[!htb]
\inputminted[]{C}{code/hilodirect.c}
\caption{\texttt{hilodirect.c}, a colorized version of the guessing game.}
\label{list:hilodirect}
\end{listing}

Stepping through the orders of magnitude\footnote{\texttt{\_\_builtin\_clzl()}
is a compiler intrinsic for \textit{count leading zeroes}. Exhaustive methods
for fast clzl can be found in \cite{hackerdelight}. Demonstrating that
absolute value of the difference of leading zeroes is a $lg_{2}$ difference
is left as an exercise for the reader.}, we get the expected gradient
(Figure~\ref{fig:colorguess}). Were we to actually play, the response would
converge to a balanced, strong green as we approached the correct answer.

\begin{figure}[!htb]
\centering \includegraphics[width=.75\linewidth]{media/hilodirect.png}
\caption{Colorized output from~\texttt{hilodirect.c}.}
\label{fig:colorguess}
\end{figure}

\subsection{Advanced coëxistence with stdio}
It is most common to initialize Notcurses with \texttt{stdout}, whether in
direct mode or fullscreen mode. This isn't the only way to operate, though.
By opening the tty directly using \texttt{/dev/tty}%\cite{tty4}%
, and providing
this \texttt{FILE*} to Notcurses, a program passing its standard output to
another process can make concurrent use of Notcurses on the display, in either
direct or fullscreen mode. This is how the \texttt{notcurses-pipe} program
works\footnote{See \url{https://github.com/dankamongmen/notcurses/issues/381}.}.

For programs that need to write to the terminal, but want to ``overlay'' some
Notcurses, fullscreen mode won't work (though the program could be run in an
\texttt{ncprocess} widget; see Chapter~\ref{sec:uiwidgets}). Direct mode, however, is
a possibility. I've not yet written the example\footnote{Send me patches! Or
I'll do it\ldots eventually \url{https://github.com/dankamongmen/notcurses/issues/382}.}, but it is possible to, for
instance, periodically acquire the current cursor position, move elsewhere on
the screen, update a HUD, and return to the departure position. Scrolling could
be addressed by retaining a copy of any obliterated output. This would suffer
a startup period of one screen, during which the area scrolled above the HUD
would be cleared. This could be avoided by aligning the HUD with the top of
the terminal.

\subsection{Use in multithreaded environments}
\label{sec:directthreads}
Direct mode calls reduce to a cached terminfo lookup and \texttt{fprint(3)}
calls on the provided \texttt{FILE*}. The former is read-only; all necessary
elements are acquired from terminfo at the time of context creation. The latter
has the same thread semantics as \texttt{fprintf(3)}: while it is \textit{safe}
for multiple threads to concurrently print to the same \texttt{FILE*}, there are
no guarantees of ordering or even atomicity. Given the existence of multibyte
UTF-8 output, let alone potentially lengthy escape sequences, it's thus practically
necessary that multiple threads working with the same \texttt{FILE*} work exclusively.

Multiple threads may freely call read-only functions such as \texttt{ncdirect\_fg()}.

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using fullscreen mode}
\label{sec:fullscreen}
\epigraph{This is how space begins, with words only, signs traced on the blank page. To describe space: to name it, to trace it, like those portolano-makers who saturated the coastlines with the names of harbours, the names of capes, the names of inlets, until in the end the land was only separated from the sea by a continuous ribbon of text. Is the aleph, that place in Borges from which the entire world is visible simultaneously, anything other than an alphabet?}{Georges Perec, \textit{Species of Spaces}}
From this chapter forward, we will be using the fullscreen mode of Notcurses,
opening up all of its capabilities. This comes at a cost: while fullscreen mode
is being used, it is not safe to use standard I/O in conjunction with the
terminal controlled by Notcurses. Doing so is likely to (at a minimum) corrupt
the screen. If \texttt{stdout} and \texttt{stderr} are attached to the same
terminal (as they usually are in an interactive session), and \texttt{stdout}
is provided to Notcurses, output to \texttt{stderr} will corrupt the display
just as thoroughly as output to \texttt{stdout}. If your fullscreen Notcurses
program intends to log to \texttt{stderr}, you should first ensure that
it has been redirected or is otherwise going somewhere different than
\texttt{stdout}. Note that simply rerendering the output will \textit{not}
necessarily clean up corruption, even following \texttt{ncplane\_erase()}
operations, since Notcurses optimizes its rendering based on its concept of the
screen. A call to \texttt{notcurses\_refresh()} will be necessary to sync
the physical screen to Notcurses's concept thereof.

It is possible for the screen to be corrupted by external agents. For this
reason, Ctrl+L is by tradition bound to screen redrawing. You should hook this
input up to \texttt{notcurses\_refresh()} unless you have good reasons not to
do so (this is not default behavior of Notcurses only because Notcurses does
not itself drive the reading of input). It is sadly not possible for such
corruption to be efficiently and generally detected.

It is possible for the attached terminal to be resized, especially (but not
only) for terminal emulators in GUI windowing environments\footnote{This could
also happen when refitting a \texttt{screen} or \texttt{tmux} session.
Even on the Linux or FreeBSD console, this can happen due to a change in video
resolution.}. Notcurses can detect such events, and synthesizes
\texttt{NCKEY\_RESIZE} inputs in response to them. If the screen shrinks, the
excess data relative to the constant origin will no longer be displayed (i.e.
the material in the upper left will be retained). If the screen is enlarged,
any data uncovered will be displayed, and the new area will otherwise be empty.
Some widgets can intelligently resize themselves in the face of screen
geometry changes (see Chapter~\ref{sec:uiwidgets}).

Notcurses prepares a given terminal for fullscreen mode in \texttt{notcurses\_init()}

\begin{listing}[!htb]
\begin{minted}{C}
// Initialize a notcurses context on the connected terminal at 'fp'. 'fp' must
// be a tty. You'll usually want stdout. Returns NULL on error, including any
// failure initializing terminfo.
struct notcurses* notcurses_init(const notcurses_options* opts, FILE* fp);

// Destroy a notcurses instance, restoring the terminal to its original state.
int notcurses_stop(struct notcurses* nc);
\end{minted}
\caption{Initializing and stopping fullscreen mode.}
\end{listing}

Before calling \texttt{notcurses\_init()} (and usually as one of the first lines
of the program) it is necessary to set the current locale via the standard
library function \texttt{setlocale()}. A coverage of ANSI/ISO C locales is beyond
the scope of this text, but it is usually sufficient to call
\texttt{setlocale(LC\_ALL, "")}, relying on the user's configured \texttt{LANG}
environment variable. Notcurses only supports those locales using
US-ASCII or UTF-8 encodings (see Chapter~\ref{section:unicode} for more
information on character encodings), and its capabilities on US-ASCII
are \textit{severely} constrained. \texttt{notcurses\_init()} will return an
error for any other encoding (see Figure~\ref{fig:encodingfail}).

\begin{figure}[!htb]
\centering \includegraphics[width=.7\linewidth]{media/notcurses-init-fails.png}
\caption{Notcurses refusing to start due to an unsupported character encoding.}
\label{fig:encodingfail}
\end{figure}

By default (assuming the \texttt{enter\_ca\_mode} terminfo capability is expressed),
Notcurses attempts to enter the ``\gls{smcup}''. Using the alternate screen
implies:
\begin{denseitemize}
\item{The screen will be cleared upon entry,}
\item{Output will not be appended to the scrollback buffer, and}
\item{On exit, output will be cleared.}
\end{denseitemize}
Whether or not the original screen contents are restored is terminal-dependent
(if the \texttt{non\_rev\_rmcup} terminfo capability is defined, the original
contents will \textit{not} be restored). The alternate screen is generally
useful, but some users don't like it, so it's wise to expose this via a
configuration option. Disabling use of the alternate screen can be done via the
\texttt{notcurses\_options} field \texttt{inhibit\_alternate\_screen}.

Successful creation of a \texttt{struct notcurses} implies the existence of
a \texttt{struct ncplane}, the ``standard plane''\footnote{\texttt{ncplane}s,
discussed in depth in Chapter~\ref{ncplane}, are the fundamental drawing surfaces of Notcurses.}.
This standard plane cannot be destroyed without destroying the containing
Notcurses context, nor can it be moved or resized by the user. Its size always
matches Notcurses's concept of the terminal's screen size, and its origin
always corresponds precisely to the terminal's origin\footnote{Some will note
clear similarities to the X ``root window''\cite{joyofx}.}. Aside from these
restrictions, the standard plane is a drawable surface like any other
\texttt{ncplane}---it can be moved along the z-axis, written to with arbitrary
glyphs and styles, made transparent, etc.

Once you're done using a \texttt{struct notcurses}, it's important to destroy
it with \texttt{notcurses\_stop()}, even if your process exits abnormally. By
default, Notcurses registers signal handlers for most fatal signals. These
handlers will call \texttt{notcurses\_stop()} and then pass the signal to the
original actions. You can disable this with the \texttt{no\_quit\_sighandlers}
field of \texttt{notcurses\_options}, but there aren't very many good reasons
to do so.

\subsection{The \texttt{notcurses\_options} structure}
The first parameter to \texttt{notcurses\_init()} is a (possibly \texttt{NULL})
\texttt{notcurses\_options}. This structure has been defined such that the
default options are equivalent to a zero-initialized structure. Passing \texttt{NULL}
is thus equivalent to passing a zero-initialized \texttt{notcurses\_options}\footnote{Except
it's strong against changes to \texttt{notcurses\_options}'s size!}.
The fields therein include:
\begin{denseitemize}
\item{\texttt{const char* termtype}: The name of the terminfo database entry to
    use. If \texttt{NULL}, the value of the environment variable \texttt{TERM}
    is used. Failure to initialize the terminfo database will result in a
    \texttt{notcurses\_init()} failure.} A defined but invalid or suboptimal
    entry can result in garbage, missing output, poor performance, reduced
    colors, and unsightly weight gain.
\item{\texttt{bool inhibit\_alternate\_screen}: As noted above, this prevents
    Notcurses from making use of the alternate screen, even if the \texttt{enter\_ca\_mode}
    terminfo capability is defined. It's best to wire this up to a user-managed
    option. Not using the alternate screen can look weird upon return to the
    shell (see Figure~\ref{fig:altscreen}).

\begin{figure}[!htb]
\centering \includegraphics[width=.7\linewidth]{media/no-alternate-screen.png}
\caption[Inhibiting use of the alternate screen.]{\texttt{notcurses-demo} can be invoked with \texttt{-k} to avoid
  using the alternate screen. Here, we see its output left on the screen as
  we return to our shell.}
\label{fig:altscreen}
\end{figure}
  }
\item{\texttt{bool retain\_cursor}: Notcurses hides the cursor by default.
    Set this to keep the cursor visible (the cursor can be turned on and off
    at runtime with \texttt{notcurses\_cursor\_enable()} and
    \texttt{notcurses\_cursor\_disable()}).}
\item{\texttt{bool suppress\_banner}: At startup, Notcurses emits some
    diagnostics and/or warnings, including version information and details
    about the current terminal. At shutdown, it prints performance statistics.
    These outputs \textit{do not} go to the alternate screen. Set this
    field to disable these outputs, but be aware that doing so might hide
    important warnings (see Figure~\ref{fig:banner}).

    \begin{figure}[!htb]
      \centering \includegraphics[width=.7\linewidth]{media/notcurses-banner.png}
      \caption[Notcurses initialization warnings.]{Initializing Notcurses without 24-bit color support will
        generate a warning, hopefully provoking your users to set it up.}
      \label{fig:banner}
    \end{figure}
}
\item{\texttt{bool no\_quit\_sighandlers}, \texttt{bool no\_winch\_sighandler}:
    As noted above, Notcurses by default registers signal actions for the normally fatal
    \texttt{SIGABRT}, \texttt{SIGINT}, \texttt{SIGQUIT}, and \texttt{SIGSEGV}.
    These handlers will call \texttt{notcurses\_stop()} before propagating the
    signal to the original actions. This is usually desirable, as the screen
    will not otherwise be restored to its previous state. In addition, \texttt{SIGWINCH}
    is caught in order to generate \texttt{NCKEY\_RESIZE} inputs. If you
    disable these handlers, you'll almost certainly want to replace them with
    similar functionality.}
\item{\texttt{FILE* renderfp}: If not \texttt{NULL}, this designates a file
    handle open for writing. In addition to the terminal, each rendered scene
    will be written to this file. This is intended for debugging.}
\item{\texttt{int margin\_t}, \texttt{int margin\_r},\texttt{int margin\_b}, \texttt{int margin\_l}}:
    Margin requests on the top, right, bottom, and left, respectively, of
    the rendering area (see Figure~\ref{fig:margins}). These requests will be satisfied on a best-effort
    basis---requesting more margin than is actually available is not an error.
    There must always be at least one row and one column available. If the
    alternate screen is being used, the margin areas will be cleared. Otherwise,
    they will be left uncleared. The margins are recomputed on a resize.
\end{denseitemize}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=.75\linewidth]{media/margins.png}
    \caption{Margins can be used around the rendering area.}
    \label{fig:margins}
\end{figure}

\subsection{Functions on \texttt{notcurses} objects}
\label{sec:notcursesfuncs}
Output is not written to this top-level \texttt{struct notcurses}---that's
done with \texttt{ncplane}s---but there are a number of functions
available for these objects. Acquiring an \texttt{ncplane} for output can be
done by grabbing a reference to the standard plane, or creating a new plane.
New planes are always inserted into the top of the z-axis. All user-created
planes can be destroyed in one call with \texttt{notcurses\_drop\_planes()} (note
that it is not necessary to call this prior to \texttt{notcurses\_stop()}; the
latter cleans up all resources associated with the context).

\begin{listing}[!htb]
\begin{minted}{C}
// Get a reference to the standard plane (one matching our current idea of the
// terminal size) for this terminal. The standard plane always exists, and its
// origin is always at the uppermost, leftmost cell of the terminal.
struct ncplane* notcurses_stdplane(struct notcurses* nc);
const struct ncplane* notcurses_stdplane_const(const struct notcurses* nc);

// notcurses_stdplane(), plus free bonus dimensions written to non-NULL y/x!
static inline struct ncplane* notcurses_stddim_yx(struct notcurses* nc, int* restrict y, int* restrict x){
  struct ncplane* s = notcurses_stdplane(nc); // can't fail
  ncplane_dim_yx(s, y, x); // accepts NULL
  return s;
}

// Return our current idea of the terminal dimensions in rows and cols.
static inline void notcurses_term_dim_yx(struct notcurses* n, int* restrict rows, int* restrict cols){
  ncplane_dim_yx(notcurses_stdplane(n), rows, cols);
}

// Create a new ncplane at the specified offset (relative to the standard plane)
// and the specified size. The number of rows and columns must both be positive.
// This plane is initially at the top of the z-buffer, as if ncplane_move_top()
// had been called on it. The void* 'opaque' can be retrieved (and reset) later.
struct ncplane* ncplane_new(struct notcurses* nc, int rows, int cols, int yoff, int xoff, void* opaque);

// Return the topmost ncplane, of which there is always at least one.
struct ncplane* notcurses_top(struct notcurses* n);

// Destroy any ncplanes other than the stdplane.
void notcurses_drop_planes(struct notcurses* nc);

// Retrieve the contents of the specified cell as last rendered. The EGC is returned, or NULL on error.
// This EGC must be free()d by the caller.
char* notcurses_at_yx(struct notcurses* nc, int yoff, int xoff, uint32_t* attr, uint64_t* channels);
\end{minted}
\caption{Essential functions on \texttt{notcurses} objects.}
\end{listing}

Reading input is a per-context operation, performed with \texttt{notcurses}
objects. It is discussed in detail in Chapter~\ref{sec:input}. When reading
input, we might get the synthesized event \texttt{NCKEY\_RESIZE}\footnote{This
event is generated upon receipt of a \texttt{SIGWINCH} signal, SIGnifying WINdow
CHange.}. This indicates that the terminal has been resized, and we might want
to call \texttt{notcurses\_resize()} and get the new dimensions. As discussed
earlier, sometimes the display is externally corrupted. It's thus a good idea
to hook some UI event (usually Ctrl+L) to \texttt{notcurses\_refresh()}, which
redraws every cell on the display according to the internal Notcurses
framebuffer.

\begin{listing}[!htb]
\begin{minted}{C}
// Refresh our idea of the terminal's dimensions, reshaping the standard plane
// if necessary. References to ncplanes (and the egcpools underlying cells)
// remain valid following a resize, but the cursor might have changed position.
int notcurses_resize(struct notcurses* n, int* restrict y, int* restrict x);

// Refresh the physical screen to match what was last rendered (i.e., without
// reflecting any changes since the last call to notcurses_render()). This is
// primarily useful if the screen is externally corrupted.
int notcurses_refresh(struct notcurses* n);
\end{minted}
\caption{Dealing with external events.}
\end{listing}

Finally, \texttt{notcurses\_render()} synthesizes a terminal's worth of current
state out of all your virtual objects, schedules an optimized list of escape
sequences and encoded characters, and blits the result to the terminal. Only
through \texttt{notcurses\_render()} (and transitively through its callers) ought
your program write to the actual terminal, and only \texttt{notcurses\_render()}
has any bearing on what the user sees. Between calls, you are free to do whatever
you want in terms of moving, reordering, creating, writing upon, and destroying
planes. There will be no flicker or tearing; what you last rendered remains on
the screen. When you've got your stack how you want it, and only then, invoke
\texttt{notcurses\_render()}. It is an exclusive function---any concurrent use
of the same \texttt{struct notcurses} is undefined.

\begin{listing}[!htb]
\begin{minted}{C}
// Make the physical screen match the virtual screen. Changes made to the
// virtual screen (i.e. most other calls) will not be visible until after a
// successful call to notcurses_render().
int notcurses_render(struct notcurses* nc);
\end{minted}
\caption{Rendering syncs the physical display to our visual planes.}
\end{listing}

\subsection{Reading, rendering, rasterizing, and writing}
\label{sec:rendering}

Understanding how Notcurses translates its data structures into a terminal
display is critical for reasoning about your program in general, and particularly
relevant for maximizing performance.

During initialization of a terminal, unless \texttt{suppress\_banner} is supplied
in \texttt{notcurses\_options}, \texttt{notcurses\_init()} will print some
diagnostics to stdout, and flush the output buffer. Notcurses maintains an
internal virtual framebuffer, containing the state of the terminal as believed
to exist\footnote{Do not confuse this with the standard plane. This framebuffer
reflects rendering and rasterizing, not the output API.}. It is initialized in
\texttt{notcurses\_init()} to an empty matrix of cells, each cell having the
default foreground and background.

What happens next depends on whether the ``alternate screen'' (as described
earlier) is employed. If so, the terminal will be immediately cleared.
Otherwise, the terminal will not be altered until the first call to
\texttt{notcurses\_render()}. That first call, however, will write to every
cell of the terminal, effectively clearing any existing output. The upshot is
that it is not possible to integrate preexisting data into your TUI, regardless
of whether the alternate screen is used (aside from marginalia). This reflects
the impossibility of portably discovering the state of the terminal.

Subsequent to the first call, Notcurses---having written them---has a concept
of the display's contents. From that point on, screen updates will write only
to changed (``damaged'') cells. When only parts of the screen have changed,
this saves a tremendous amount of work. On an 80x45 terminal, if only a 10x10
region of cells have changed, we reduce our bandwidth by about
95\%\footnote{10x10 is only 2.7\% of 80x45, but there is overhead due to moving
the cursor to the region, and then positioning the cursor at the end of each
line of the region.}. These savings are multiplicative:

\begin{denseitemize}
\item{Notcurses doesn't have to \texttt{write()} the data (memory copy).}
\item{The terminal doesn't have to \texttt{read()} the data (memory copy).}
\item{The terminal doesn't need to process the data (assorted work).}
\item{The terminal doesn't need to write to the display (memory copy).}
\end{denseitemize}

Whether a cell has been updated is decided at rasterization time. Writing to
that cell between calls to \texttt{notcurses\_render()} does not necessarily
mean the cell will be considered damaged when it comes time to write. If the
cell has been damaged, it will be emitted, and the virtual framebuffer internal
to Notcurses will be updated.

Solving for the desired state of the screen is \textit{rendering}, and this is
the first step of \texttt{notcurses\_render()}. Solving for the screen means
solving for the current state of every cell, given our ordered set of
\texttt{ncplane}s. Solving for a cell means determining the extended grapheme
cluster to be rendered, determining the attributes to be applied to that EGC,
and determining the colors in which it ought be displayed. The higher a plane
is on the z-axis, the more it can impact these solutions:

\begin{denseitemize}
\item{The EGC and attribute are determined by the first plane intersecting with
      the cell having a non-null EGC at the intersecting coordinate. If there is
    no such intersecting EGC, the EGC is null, and the attribute is
    \texttt{NCSTYLE\_NORMAL}.} Null EGCs are rendered as spaces (i.\ e.\ entirely
    background color).
\item{The foreground color is determined by the first instance of a
    \texttt{CELL\_ALPHA\_OPAQUE} foreground color, or an instance of the
    default foreground color, or an instance of a palette-indexed foreground
    color, as well as any \texttt{CELL\_ALPHA\_HIGHCONTRAST} or \texttt{CELL\_ALPHA\_BLEND}
    foreground colors encountered along the way. If there is no such
    intersecting terminator, the foreground color is the color as calculated
    thus far. If \texttt{CELL\_ALPHA\_HIGHCONTRAST} is in play, the calculated
    color is then blended to stand out against the calculated background
    color.}
\item{The background color is determined independently, in the same way as the
    foreground color, except without the complicating possibility of
    \texttt{CELL\_ALPHA\_HIGHCONTRAST}.}
\end{denseitemize}

Once a cell is solved, Notcurses needn't continue inspecting lower planes at
that coordinate. Once all cells are solved, rendering is complete, and any
planes left over can be skipped entirely. Until then, Notcurses steps down from
one plane to the next, starting at the topmost plane, and updates its solution
for any intersecting unsolved cells. It is thus generally more performant to
``hide'' planes at the bottom of the stack, ideally behind a large opaque plane,
rather than moving them beyond the boundaries of the visible window. Likewise,
planes ought be no larger than necessary, so that they intersect with the
minimum number of cells. Note that there will always be at least one plane
interacting with each visible coordinate, due to the properties of the standard
plane.

Having rendered the scene, \textit{rasterization} serializes a buffer to write
to the terminal, minimizing the amount of data by moving the cursor over undamaged
regions. This is the second step of \texttt{notcurses\_render()}. Writing this
data to the terminal as it's generated is a bad idea for several reasons: it can
provoke unnecessary context switches, it results in partially-updated displays,
and it definitely involves more system calls. Notcurses instead collects it in
one or more large allocations.

Proceeding cell-by-cell from the upper left to the lower right, Notcurses
compares the rendering solution set to its internal framebuffer. If a given row
is entirely undamaged, it can be skipped. Upon discovering the leftmost damage
on a row, an absolute cursor update is performed to the damaged cell. At each
damaged cell, the EGC will be emitted, along with any necessary styling
information. It is only necessary to emit styling escapes when they change, i.\ e.\ we
can emit multiple EGCs having the same style after only issuing the appropriate
escapes once. An RGB change takes about 14 bytes, a palette index change
takes about 6, and reverting to the default 2. For single-byte simple (ASCII)
EGCs, an RGB foreground and background represent 2800\% overhead per cell!
Eliding styling escapes is thus an important secondary optimization (it's of
course most desirable to not update the cell at all). Using the ``default
color'' as only one of the foreground or background requires emitting the
\texttt{op} escape followed by the appropriate escape for changing the fore- or
background (since \texttt{op} changes both at once).

Certain EGCs are understood to be all-foreground or all-background.
\texttt{U+2588 FULL BLOCK} is all foreground. \texttt{U+0020 SPACE} is all
background. When such characters are used, notcurses will emit whichever
character requires the fewest total bytes, taking into account both the
UTF-8 encoding length and the current color state.

The upshot is that holding styling constant across a horizontal stretch is
very desirable if that range's content is going to be changing. The most
pathological input to Notcurses is text that changes its foreground and background
on a cell-to-cell basis, especially when specified as RGB, that change from
render to render. Certain terminal emulators in particular respond to the
resulting deluge of RGB escapes very poorly (see Appendix~\ref{sec:termshade}).
As examples, see the \texttt{highcontrast} and \texttt{grid} demos of
\texttt{notcurses-demo}---a large \texttt{xterm} can be brought to its knees
by these routines.

Each subsequent range of undamaged cells on a line can be skipped over with
cursor movements, but as the skip length approaches 1, it becomes less and
less advantageous to do so. Rendering performance can be very roughly
categorized as inversely proportional to the product of:

\begin{denseitemize}
\item{color changes across the rendered screen,}
\item{planar depth before an opaque glyph and background are locked in,}
\item{number of UTF-8 bytes comprising the rendered glyphs, and}
\item{screen geometry.}
\end{denseitemize}

With these buffers in hand, \texttt{notcurses\_render()} completes its task by
writing them to the terminal. This almost certainly means copying
them into a kernel buffer from which the terminal will then (following at
least one context switch and two system calls) read. Writing does not,
then, necessarily mean that the display has actually been updated, or even
that the terminal has read the data. If the terminal doesn't empty the buffer
quickly enough, however, you'll eventually run out of room and block. It is
thus critical to understand that \textbf{\texttt{notcurses\_render()} can block
for arbitrary amounts of time}\footnote{But see
\url{https://github.com/dankamongmen/notcurses/issues/214}.}. Furthermore,
if the terminal reads two renderings' worth of output at the same time, it is
likely to immediately enter the final state---you must not assume that a successful
\texttt{notcurses\_render()} is necessarily displayed within any arbitrary time,
or indeed that it corresponds with any displayed frame.

With those unhappy truths said, modern workstations ought have no problem pushing
notcurses onto commodity hardware at maximum framerates, with the terminal
faithfully reproducing each rendered scene. Even small microcontrollers ought
be able to render notcurses without user-perceptible latency. On a powerful
desktop with non-pathological output, it's easy to render in excess of
ten thousand frames per second, more than an order of magnitude beyond the
refresh capabilities of any existing or likely monitor\cite{charni}.

\subsection{Capabilities}
\label{sec:capabilities}
Different terminals expose different capabilities, and different means of
engaging them. These differences are encoded in the terminfo database\cite{terminfo}.
Notcurses hides the differences where it can, and is built around those
capabilities which are most widely supported. Some applications, however, will
want to know details of the underlying implementation. For this purpose, the
Capabilities API is provided (Listing~\ref{list:capabilities}).
\begin{listing}[!htb]
\begin{minted}{C}
// Returns a 16-bit bitmask of supported curses-style attributes (NCSTYLE_UNDERLINE, NCSTYLE_BOLD,
// etc.). The attribute is only indicated as supported if the terminal can support it together
// with color. For more information, see the "ncv" capability in terminfo(5).
unsigned notcurses_supported_styles(const struct notcurses* nc);

// Returns the number of simultaneous colors claimed to be supported, or 1 if there is no color support.
// Note that several terminal emulators advertise more colors than they actually support, downsampling internally.
int notcurses_palette_size(const struct notcurses* nc);

// Can we fade? Fading requires either the "rgb" or "ccc" terminfo capability.
bool notcurses_canfade(const struct notcurses* nc);

// Can we set the "hardware" palette? Requires the "ccc" terminfo capability.
bool notcurses_canchangecolor(const struct notcurses* nc);

// Can we load images/videos? This requires being built against FFmpeg.
bool notcurses_canopen(const struct notcurses* nc);

// Get a human-readable string describing the running notcurses version.
const char* notcurses_version(void);
\end{minted}
\caption{The capabilities API.}
\label{list:capabilities}
\end{listing}

\subsection{Statistics}
Notcurses tracks statistics across its operation, and a snapshot can be
acquired using the \texttt{notcurses\_stats()} function (Listing~\ref{list:stats}). This function cannot
fail. Most of the stats can be reset with \texttt{notcurses\_reset\_stats()}.
This function resets all cumulative stats, but not those which describe the
current state. Timings for renderings are across the breadth of
\texttt{notcurses\_render()}: they include all per-render preprocessing, output
generation, and dumping of the output (including any sleeping while blocked on
output to the terminal).

Statistics available include:
\begin{denseitemize}
\item{\texttt{renders}, \texttt{failed\_renders}: The number of successful and unsuccessful
    invocations of \texttt{notcurses\_render()}. Calls to \texttt{notcurses\_refresh()} do
    not show up in either of these stats. A render call can fail due to
    memory pressure, invalid EGCs, or a failure to successfully write to the
    output terminal.}
\item{\texttt{render\_bytes}: The number of bytes written in successful renders.
    Unsuccessful renders do not count towards the total. Dividing \texttt{renders}
  by \texttt{render\_bytes} yields the average bytes per (successful) render.}
\item{\texttt{render\_max\_bytes}, \texttt{render\_min\_bytes}: The maximum and
  minimum number of bytes emitted during a successful render.}
\item{\texttt{render\_ns}, \texttt{render\_min\_ns}, \texttt{render\_max\_ns}:
  The total, minimum, and maximum number of nanoseconds spent in \texttt{notcurses\_render()},
  whether the calls were successful or not. These timings are acquired using
  POSIX timers\cite{clockgettime} with the
  \texttt{CLOCK\_MONOTONIC}\footnote{Wouldn't \texttt{CLOCK\_MONOTONIC\_RAW} be
  superior? It would, where it's available, which isn't everywhere. It's also
  substantially more expensive than \texttt{CLOCK\_MONOTONIC} on Linux. Be
  aware, then, that NTP adjustments and time suspended \textit{do} show up in
  timings.} implementation.}
\item{\texttt{cellemissions}, \texttt{cellelisions}: The total number of EGCs
  written to output, and the number that did not need to be written due to
  being undamaged.}
\item{\texttt{fgemissions}, \texttt{fgelisions}: Foreground RGB values written to output, and the number elided.}
\item{\texttt{bgemissions}, \texttt{bgelisions}: Background RGB values written to output, and the number elided.}
\item{\texttt{defaultemissions}, \texttt{defaultelisions}: \texttt{op} escapes issued to set default colors, and the number elided.}
\item{\texttt{fbbytes}: The number of bytes devoted to framebuffers.}
\item{\texttt{planes}: The current number of planes. Will never drop below 1.}
\end{denseitemize}

\begin{listing}[!htb]
\begin{minted}{C}
typedef struct ncstats {
  // purely increasing (cumulative) stats
  uint64_t renders;          // number of successful notcurses_render() runs
  uint64_t failed_renders;   // number of aborted renders, should be 0
  uint64_t render_bytes;     // bytes emitted to ttyfp
  int64_t render_max_bytes;  // max bytes emitted for a frame
  int64_t render_min_bytes;  // min bytes emitted for a frame
  uint64_t render_ns;        // nanoseconds spent in notcurses_render()
  int64_t render_max_ns;     // max ns spent in notcurses_render()
  int64_t render_min_ns;     // min ns spent in successful notcurses_render()
  uint64_t cellelisions;     // cells we elided entirely thanks to damage maps
  uint64_t cellemissions;    // cells we emitted due to inferred damage
  uint64_t fgelisions;       // RGB fg elision count
  uint64_t fgemissions;      // RGB fg emissions
  uint64_t bgelisions;       // RGB bg elision count
  uint64_t bgemissions;      // RGB bg emissions
  uint64_t defaultelisions;  // default color was emitted
  uint64_t defaultemissions; // default color was elided
  // current state -- these can decrease
  uint64_t fbbytes;          // total bytes devoted to all active framebuffers
  unsigned planes;           // number of planes currently in existence
} ncstats;

// Acquire an atomic snapshot of the notcurses object's stats.
void notcurses_stats(struct notcurses* nc, ncstats* stats);

// Reset all cumulative stats (immediate ones, such as fbbytes, are not reset).
void notcurses_reset_stats(struct notcurses* nc, ncstats* stats);
\end{minted}
\caption{The statistics API.}
\label{list:stats}
\end{listing}

\subsection{Use in multithreaded environments}
\label{sec:fullthreads}
To facilitate maximum performance, Notcurses does not perform any locking of
its own\footnote{This might change if Notcurses begins to actively acquire
input itself, necessary for certain desirable features. In that case, the
locking would only be present in the input layer.}. All functions are safe
for multiple threads to call with regards to system and standard library
resources. Things become more complex when multiple threads wish to ``write''
to Notcurses.

As mentioned above, it is necessary that \texttt{notcurses\_render()} calls
mutually exclude themselves, and also all other functions which mutate the
context. This includes all functions which write to a plane, functions which
change the ordering of planes (including deletion of a plane), and even
statistics functions. With very few exceptions, calling any Notcurses function
concurrently with \texttt{notcurses\_render()} is an error.

Beyond this ``big rendering lock'', functions ought not generally be called
concurrently on the same \texttt{ncplane}, unless all are reading. It is
unsafe, for instance, to call \texttt{ncplane\_putegc()} (a writing function)
concurrently with \texttt{ncplane\_cursor\_yx()} (a reading function). It
might not be obvious that functions such as \texttt{ncplane\_at\_yx()} which
write to a \texttt{cell} bound to the plane are writers, but supplying the
\texttt{cell} might require writing to the plane's egcpool, and thus they are
writers. In general, a function is only a reader if its \texttt{ncplane} argument
is \texttt{const}.

Concurrent operations on different planes are safe, unless they are changing
the ordering along the z-axis. Note that \texttt{ncplane\_destroy()} updates
the z-ordering by virtue of removing an element, and thus must not be called
along with e.g. \texttt{ncplane\_move\_top()}.

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{simpleloop.tex}
\pagebreak
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{ttymechanics.tex}
\pagebreak
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{chars.tex}
\pagebreak
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{planes}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% output and styling
\input{output}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lines, boxes, and fills}
\subsection{Linear interpolation (``lerping'') and lines}
\epigraph{On the plain behind him are the wanderers in search of bones and those who do not search and they move haltingly in the light like mechanisms whose movements are monitored with escapement and pallet so that they appear restrained by a prudence or reflectiveness which has no inner reality and they cross in their progress one by one that track of holes that runs to the rim of the visible ground and which seems less the pursuit of some continuance than the verification of a principle, a validation of sequence and causality as if each round and perfect hole owed its existence to the one before it there on that prairie upon which are the bones and the gatherers of bones and those who do not gather.}{Cormac McCarthy, \textit{Blood Meridian}}
\label{sec:lerps}
Following actual text, the most frequent need of a TUI is probably vertical
and horizontal lines. Notcurses allows such lines to be drawn using arbitrary
EGCs, though you'll usually want one of the Unicode Box Drawing characters
(see Figure~\ref{fig:linedrawing}) or the Block Elements
(Figure~\ref{fig:blockelements}).

\begin{figure}[!htb]
    \centering
    \includegraphics[width=.75\linewidth]{media/boxdrawing.png}
    \caption{Unicode box-drawing characters \textit{(source: Chininazu12, public domain)}.}
    \label{fig:linedrawing}
\end{figure}

Using \texttt{ncplane\_hline()} or \texttt{ncplane\_vline()}, a single cell is
provided, and this cell (including its attributes and channels) is reproduced
on each cell of the line\footnote{If you provide a multicolumn EGC\textellipsis
I have no idea what happens. Maybe it works? I should look into that, huh.}.
Two additional forms are provided: \texttt{ncplane\_hline\_interp()} and
\texttt{ncplane\_vline\_interp()} (see Listing~\ref{list:lines}). Both of these
accept two channel pairs, and perform a linear interpolation between the two
foreground and two background channels. Providing the equivalent values for
either channel will result in that channel remaining constant along the line's
length.

\begin{listing}[!htb]
\begin{minted}{C}
// Draw horizontal or vertical lines using the specified cell, starting at the current cursor position. The
// cursor will end at the cell following the last cell output (even, perhaps counter-intuitively, when
// drawing vertical lines), just as if ncplane_putc() was called at that spot. Return the number of cells
// drawn on success. On error, return the negative number of cells drawn.
int ncplane_hline_interp(struct ncplane* n, const cell* c, int len, uint64_t c1, uint64_t c2);

static inline int ncplane_hline(struct ncplane* n, const cell* c, int len){
  return ncplane_hline_interp(n, c, len, c->channels, c->channels);
}

int ncplane_vline_interp(struct ncplane* n, const cell* c, int len, uint64_t c1, uint64_t c2);

static inline int ncplane_vline(struct ncplane* n, const cell* c, int len){
  return ncplane_vline_interp(n, c, len, c->channels, c->channels);
}
\end{minted}
\caption{Functions for drawing lines.}
\label{list:lines}
\end{listing}

\subsection{Boxes}
\label{sec:boxes}
Rectangles are regularly required as borders and for grouping. Notcurses supports
flexible box drawing. Boxes have their upper-left corner at the current cursor
position, unless drawn with \texttt{ncplane\_perimeter()}, which draws along the
edges of the plane (and has its upper-left corner at the plane origin). Box-drawing
functions accept six \texttt{cell} objects, one for each corner, one for horizontal
lines, and one for vertical lines. It is possible to apply linear interpolation
between the corners, in which case the colors of the horizontal and vertical
line-drawing cells will be ignored. It is possible to draw none, all, or any set
of the four corners and none, all, or any set of the four sides. These configurable
behaviors are specified via the \texttt{ctlword} bitmask parameter.
\texttt{ctlword} is defined in the least significant byte, where bits 4--7 are
a gradient mask, and 0--3 are a border mask (see Table~\ref{table:boxes}).

\begin{table}[!htb]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    Constant & Bit & Property \\
    \hline
    \hline
    \texttt{NCBOXMASK\_TOP} & 0x001 & Inhibit top \\
    \hline
    \texttt{NCBOXMASK\_RIGHT} & 0x002 & Inhibit right \\
    \hline
    \texttt{NCBOXMASK\_BOTTOM} & 0x004 & Inhibit bottom \\
    \hline
    \texttt{NCBOXMASK\_LEFT} & 0x008 & Inhibit left \\
    \hline
    \texttt{NCBOXGRAD\_TOP} & 0x010 & Left side linear interpolation \\
    \hline
    \texttt{NCBOXGRAD\_RIGHT} & 0x020 & Bottom side linear interpolation \\
    \hline
    \texttt{NCBOXGRAD\_BOTTOM} & 0x040 & Right side linear interpolation \\
    \hline
    \texttt{NCBOXGRAD\_LEFT} & 0x080 & Top side linear interpolation \\
    \hline
    x & 0x100 & Require 1 connecting edge to draw corner \\
    \hline
    x & 0x200 & Require 2 connecting edges to draw corner \\
    \hline
    x & 0x300 & Draw no corners \\
    \hline
  \end{tabular}
  \caption{\texttt{ctlword} parameter for box-drawing.}
  \label{table:boxes}
\end{table}

By default, vertexes are drawn whether their connecting edges are drawn or
not. The value of the bits corresponding to \texttt{NCBOXCORNER\_MASK} (0x300)
control this, and are interpreted as the number of connecting edges necessary to draw a
given corner. At 0 (the default), corners are always drawn. At 3, corners
are never drawn (as at most 2 edges can touch a box's corner).

\begin{listing}[!htb]
\begin{minted}{C}
int ncplane_box(struct ncplane* n, const cell* ul, const cell* ur, const cell* ll, const cell* lr,
                const cell* hline, const cell* vline, int ystop, int xstop, unsigned ctlword);

// Draw a box with its upper-left corner at the current cursor position, having dimensions 'ylen'x'xlen'.
// See ncplane_box() for more information. The minimum box size is 2x2, and it cannot be drawn off-screen.
static inline int
ncplane_box_sized(struct ncplane* n, const cell* ul, const cell* ur, const cell* ll,
                  const cell* lr, const cell* hline, const cell* vline, int ylen, int xlen, unsigned ctlword){
  int y, x;
  ncplane_cursor_yx(n, &y, &x);
  return ncplane_box(n, ul, ur, ll, lr, hline, vline, y + ylen - 1, x + xlen - 1, ctlword);
}

static inline int
ncplane_perimeter(struct ncplane* n, const cell* ul, const cell* ur, const cell* ll,
                  const cell* lr, const cell* hline, const cell* vline, unsigned ctlword){
  if(ncplane_cursor_move_yx(n, 0, 0)){
    return -1;
  }
  int dimy, dimx;
  ncplane_dim_yx(n, &dimy, &dimx);
  return ncplane_box_sized(n, ul, ur, ll, lr, hline, vline, dimy, dimx, ctlword);
}
\end{minted}
\caption{Functions for drawing rectilinear boxes.}
\label{list:boxes}
\end{listing}

It can be tedious to set up the six \texttt{cell} parameters to these
functions. Since boxes are typically drawn with one of a small number of sets
of EGCs, helper functions are provided for each set. I usually go with the
pleasantly rounded ``Light Arc'' Box Drawing codes
(Listing~\ref{list:roundboxes}). Or, should you prefer, there are
the strong, sure Double Box Drawing characters
(Listing~\ref{list:doubleboxes}).

\begin{listing}[!htb]
\begin{minted}{C}
static inline int cells_rounded_box(struct ncplane* n, uint32_t attr, uint64_t channels,
                                    cell* ul, cell* ur, cell* ll, cell* lr, cell* hl, cell* vl){
  return cells_load_box(n, attr, channels, ul, ur, ll, lr, hl, vl, "╭╮╰╯─│");
}

static inline int ncplane_rounded_box(struct ncplane* n, uint32_t attr, uint64_t channels,
                                      int ystop, int xstop, unsigned ctlword){
  int ret = 0;
  cell ul = CELL_TRIVIAL_INITIALIZER, ur = CELL_TRIVIAL_INITIALIZER;
  cell ll = CELL_TRIVIAL_INITIALIZER, lr = CELL_TRIVIAL_INITIALIZER;
  cell hl = CELL_TRIVIAL_INITIALIZER, vl = CELL_TRIVIAL_INITIALIZER;
  if((ret = cells_rounded_box(n, attr, channels, &ul, &ur, &ll, &lr, &hl, &vl)) == 0){
    ret = ncplane_box(n, &ul, &ur, &ll, &lr, &hl, &vl, ystop, xstop, ctlword);
  }
  cell_release(n, &ul); cell_release(n, &ur);
  cell_release(n, &ll); cell_release(n, &lr);
  cell_release(n, &hl); cell_release(n, &vl);
  return ret;
}

static inline int
ncplane_rounded_box_sized(struct ncplane* n, uint32_t attr, uint64_t channels, int ylen, int xlen, unsigned ctlword){
  int y, x;
  ncplane_cursor_yx(n, &y, &x);
  return ncplane_rounded_box(n, attr, channels, y + ylen - 1, x + xlen - 1, ctlword);
}
\end{minted}
\caption{Helpers for rounded-corner boxes.}
\label{list:roundboxes}
\end{listing}

\begin{listing}[!htb]
\begin{minted}{C}
static inline int cells_double_box(struct ncplane* n, uint32_t attr, uint64_t channels,
                                   cell* ul, cell* ur, cell* ll, cell* lr, cell* hl, cell* vl){
  return cells_load_box(n, attr, channels, ul, ur, ll, lr, hl, vl, "╔╗╚╝═║");
}

static inline int ncplane_double_box(struct ncplane* n, uint32_t attr, uint64_t channels,
                                                  int ystop, int xstop, unsigned ctlword){
  int ret = 0;
  cell ul = CELL_TRIVIAL_INITIALIZER, ur = CELL_TRIVIAL_INITIALIZER;
  cell ll = CELL_TRIVIAL_INITIALIZER, lr = CELL_TRIVIAL_INITIALIZER;
  cell hl = CELL_TRIVIAL_INITIALIZER, vl = CELL_TRIVIAL_INITIALIZER;
  if((ret = cells_double_box(n, attr, channels, &ul, &ur, &ll, &lr, &hl, &vl)) == 0){
    ret = ncplane_box(n, &ul, &ur, &ll, &lr, &hl, &vl, ystop, xstop, ctlword);
  }
  cell_release(n, &ul); cell_release(n, &ur);
  cell_release(n, &ll); cell_release(n, &lr);
  cell_release(n, &hl); cell_release(n, &vl);
  return ret;
}

static inline int ncplane_double_box_sized(struct ncplane* n, uint32_t attr, uint64_t channels,
                                           int ylen, int xlen, unsigned ctlword){
  int y, x;
  ncplane_cursor_yx(n, &y, &x);
  return ncplane_double_box(n, attr, channels, y + ylen - 1, x + xlen - 1, ctlword);
}
\end{minted}
\caption{Helpers for doubly-thicc boxes.}
\label{list:doubleboxes}
\end{listing}

\subsection{Gradients and polyfills}
\texttt{ncplane\_polyfill()} should be applied to a coordinate with no glyph
(Listing~\ref{list:polyfills}). That coordinate will be filled with the provided
\texttt{cell}. The function then effectively recurses on all cardinally
connected coordinates, thus filling a bounded region with the provided cell.
This operation is akin to the ``flood
fill'' of pixel graphics. Sometimes you'll want to destroy all content in the
plane, reinitializing its framebuffer and base cell without changing the
geometry. \texttt{ncplane\_erase()} allows you to do this in one fell swoop,
with the added bonus functionality of resetting the associated egcpool. A
freshly-reset egcpool can be much faster than one which has been heavily used,
requiring a search to find suitable free space. The state of the framebuffer is
exactly as it was when the plane was created---all cells hold the null EGC, all
attributes are 0, and all colors are defaults. All cells associated with this
plane are invalidated, so be sure you're not holding onto any. \texttt{ncplane\_polyfill\_yx()}
and \texttt{ncplane\_erase()} are detailed in Listing~\ref{list:polyfills}.

\begin{listing}[!htb]
\begin{minted}{C}
// Starting at the specified coordinate, if it has no glyph, 'c' is copied into it. We do the same to
// all cardinally-connected glyphless cells, filling in everything behind a boundary. Returns the
// number of cells polyfilled. An invalid initial y, x is an error.
int ncplane_polyfill_yx(struct ncplane* n, int y, int x, const cell* c);

void ncplane_erase(struct ncplane* n);
\end{minted}
\caption{Polyfills and plane erasure.}
\label{list:polyfills}
\end{listing}

A single EGC and attribute can be written to a rectangular region in any of
a single color, a vertical, horizontal, or diagonal gradient, or a 4-cornered
``inverted radial'' gradient (see Listing~\ref{list:gradients}). The gradient
operation is independently applied to both the fore- and background of 4 64-bit
channel parameters. Palette-indexed color is not yet supported for gradients.

\begin{listing}[!htb]
\begin{minted}{C}
// Draw a gradient with its upper-left corner at the current cursor position, stopping at 'ystop'x'xstop'.
// The glyph composed of 'egc' and 'attrword' is used for all cells. The channels specified by 'ul', 'ur',
// 'll', and 'lr' are composed into foreground and background gradients. To do a vertical gradient, 'ul'
// ought equal 'ur' and 'll' ought equal 'lr'. To do a horizontal gradient, 'ul' ought equal 'll' and 'ur'
// ought equal 'ul'. To color everything the same, all four channels should be equivalent. The resulting
// alpha values are equal to incoming alpha values.
//
// Preconditions for gradient operations (error otherwise):
//
//  all: only RGB colors, unless all four channels match as default
//  all: all alpha values must be the same
//  1x1: all four colors must be the same
//  1xN: both top and both bottom colors must be the same (vertical gradient)
//  Nx1: both left and both right colors must be the same (horizontal gradient)
int ncplane_gradient(struct ncplane* n, const char* egc, uint32_t attrword, uint64_t ul, uint64_t ur,
                     uint64_t ll, uint64_t lr, int ystop, int xstop);

// Do a high-resolution gradient using upper blocks and synced backgrounds. This doubles the number of
// vertical gradations, but restricts you to half blocks (appearing to be full blocks).
int ncplane_highgradient(struct ncplane* n, uint32_t ul, uint32_t ur,
                         uint32_t ll, uint32_t lr, int ystop, int xstop);

// Draw a gradient with its upper-left corner at the current cursor position, having dimensions
// 'ylen'x'xlen'. See ncplane_gradient for more information.
static inline int ncplane_gradient_sized(struct ncplane* n, const char* egc, uint32_t attrword, uint64_t ul,
                                         uint64_t ur, uint64_t ll, uint64_t lr, int ylen, int xlen){
  if(ylen < 1 || xlen < 1){
    return -1;
  }
  int y, x;
  ncplane_cursor_yx(n, &y, &x);
  return ncplane_gradient(n, egc, attrword, ul, ur, ll, lr, y + ylen - 1, x + xlen - 1);
}

static inline int ncplane_highgradient_sized(struct ncplane* n, uint64_t ul, uint64_t ur,
                                             uint64_t ll, uint64_t lr, int ylen, int xlen){
  if(ylen < 1 || xlen < 1){
    return -1;
  }
  int y, x;
  ncplane_cursor_yx(n, &y, &x);
  return ncplane_highgradient(n, ul, ur, ll, lr, y + ylen - 1, x + xlen - 1);
}
\end{minted}
\caption{Drawing gradients.}
\label{list:gradients}
\end{listing}

\subsection{Blitting}
\label{sec:blitting}
\begin{listing}[!htb]
\begin{minted}{C}
// Blit a flat array 'data' of BGRx 32-bit values to the ncplane 'nc', offset from the upper left by 'placey' and 'placex'.
// Each row ought occupy 'linesize' bytes (this might be greater than lenx * 4 due to padding). A subregion of the input
// can be specified with 'begy'x'begx' and 'leny'x'lenx'.
int ncblit_bgrx(struct ncplane* nc, int placey, int placex, int linesize, const unsigned char* data,
                int begy, int begx, int leny, int lenx);

// Blit a flat array 'data' of RGBA 32-bit values to the ncplane 'nc', offset from the upper left by 'placey' and 'placex'.
// Each row ought occupy 'linesize' bytes (this might be greater than lenx * 4 due to padding). A subregion of the input can
// be specified with 'begy'x'begx' and 'leny'x'lenx'.
int ncblit_rgba(struct ncplane* nc, int placey, int placex, int linesize, const unsigned char* data,
                int begy, int begx, int leny, int lenx);
\end{minted}
\caption{Blitting BGRx and RGBA.}
\label{list:blitting}
\end{listing}

Sometimes, you've got a chunk of RGBA or BGRx in memory, and just want to blast
it onto a plane as quickly as possible. Blitting functions (see Listing~\ref{list:blitting})
exist to transform such pixels into Unicode Block Elements. Every two input rows
become a single row, using half-blocks when necessary. Columns are mapped 1-to-1.
This functionality was used, for instance, to set up Notcurses as a rendering
backend for NEStopia and RetroArch, and these functions form the heart of the
multimedia functionality described in Chapter~\ref{sec:libav}. Note that these
functions do not offer any scaling capabilities.

\subsection{Staining}
\label{sec:staining}
Consult Chapter~\ref{sec:outputtext} for the ``stainable'' family of text output
functions, allowing EGCs to be replaced without affecting attributes or channels.
To modify attributes or channels in isolation but \textit{en masse}, Notcurses
provides \texttt{ncplane\_format()} and \texttt{ncplane\_stain()}.

\begin{listing}[!htb]
\begin{minted}{C}
// Set the given style throughout the specified region, keepying content and channels otherwise unchanged.
int ncplane_format(struct ncplane* n, int ystop, int xstop, uint32_t attrword);

// Set the given channels throughout the specified region, keepying content and attributes otherwise unchanged.
int ncplane_stain(struct ncplane* n, int ystop, int xstop, uint64_t ul, uint64_t ur, uint64_t ll, uint64_t lr);
\end{minted}
\caption{Changing attributes or channels in isolation.}
\label{list:stain}
\end{listing}

Staining could be accomplished without a special function call by reflecting
on each cell of interest using \texttt{ncplane\_at\_yx()}, changing the cell,
and writing it back, but \texttt{ncplane\_stain()} and \texttt{ncplane\_format()}
are faster and simpler. Creating a new plane of all null glyphs, setting the
channels as desired, and placing it atop the region would also accomplish a
staining, and can further be used as a ``moving'' stain. This wouldn't affect
the lower plane; it would purely be an effect of rendering. It is not possible
to simulate \texttt{ncplane\_format()} in this way, however---glyph and
attribute are a single dimension and cannot be independently transparent.

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Multimedia (images and videos)}
\label{sec:libav}

Media decoding and scaling is handled by libAV from FFmpeg, resulting in a
\texttt{ncvisual} object. This object generates frames, each one
corresponding to a renderable scene on the associated plane. If Notcurses
is built without FFmpeg support, these functions will all return error.
The flow of multimedia from the view of a Notcurses application is:
\begin{denseitemize}
\item{The media is opened with \texttt{ncplane\_visual\_open()} or
    \texttt{ncvisual\_open\_plane}. The latter creates a new plane suitable
    for rendering the media; the former will draw to a preexisting plane.
    Stream format and the codecs in use are determined during this step, but
    not necessarily the geometry of the visual data.}
\item{A frame is decoded. Several frames might have been decoded from the
    underlying stream, but the application sees them one at a time. This frame
    carries geometry information along with a flat matrix of pixels, along with
    some manner of timing information\footnote{This timing information can come
    in three different forms: ``frame number'' (which can be multiplied by
    some known frames per second to get a time offset), ``offset`` in some
    unit of time, and ``time to display'' for this frame in some unit of
    time. This last sadly cannot yield an O(1) time offset within the
    stream.}. \textbf{begin loop}}
\item{(Optional) Any subtitles associated with the frame are retrieved.}
\item{The frame may be rendered. A delay might be taken. \textbf{end loop}}
\end{denseitemize}

\begin{listing}[!htb]
\begin{minted}{C}
// Open a visual (image or video), associating it with the specified ncplane.
// Returns NULL on any error, writing the AVError to 'averr'.
struct ncvisual* ncplane_visual_open(struct ncplane* nc, const char* file, int* averr);

// Destroy an ncvisual. Rendered elements will not be disrupted, but the visual
// can be neither decoded nor rendered any further.
void ncvisual_destroy(struct ncvisual* ncv);

// Return the plane to which this ncvisual is bound.
struct ncplane* ncvisual_plane(struct ncvisual* ncv);
\end{minted}
\caption{Opening and destroying multimedia with \texttt{ncvisual}.}
\label{list:ncvisual}
\end{listing}

Any scaling is applied during the decoding step. It is thus sadly not possible
to redraw decoded media at a different size. This isn't usually a problem in
practice, since streaming media will provide a new frame (at the correct size)
shortly, and single-frame media can simply be decoded afresh.

\begin{listing}[!htb]
\begin{minted}{C}
// extract the next frame from an ncvisual. returns NULL on end of file,
// writing AVERROR_EOF to 'averr'. returns NULL on a decoding or allocation
// error, placing the AVError in 'averr'. this frame is invalidated by a
// subsequent call to ncvisual_decode(), and should not be freed by the caller.
struct AVFrame* ncvisual_decode(struct ncvisual* nc, int* averr);

// Render the decoded frame to the associated ncplane. The frame will be scaled
// to the size of the ncplane per the ncscale_e style. A subregion of the
// frame can be specified using 'begx', 'begy', 'lenx', and 'leny'. To render
// the rectangle formed by begy x begx and the lower-right corner, zero can be
// supplied to 'leny' and 'lenx'. Zero for all four values will thus render the
// entire visual. Negative values for any of the four parameters are an error.
// It is an error to specify any region beyond the boundaries of the frame.
int ncvisual_render(const struct ncvisual* ncv, int begy, int begx, int leny, int lenx);
\end{minted}
\caption{Decoding and rendering multimedia with \texttt{ncvisual}.}
\label{list:multimedia}
\end{listing}

Subtitles (considered ``metadata'' in FFmpeg) aren't advertised in any way to
the caller. If subtitles are to be displayed, you can simply call \texttt{ncvisual\_subtitle()}
at each frame. If a non-\texttt{NULL} string is returned, it is valid UTF-8
subtitle text. The subtitle will \textit{not} typically be repeated for all
frames where it ought be displayed, so it's best left persistent. Unfortunately,
there's no good way to know when it ought be struck from the display. Alas!

\begin{listing}[!htb]
\begin{minted}{C}
// If a subtitle ought be displayed at this time, returns a heap-allocated copy
// of the UTF8 text. Otherwise returns NULL.
char* ncvisual_subtitle(const struct ncvisual* ncv);
\end{minted}
\caption{Acquiring subtitles.}
\label{list:subtitles}
\end{listing}

\subsection{Streaming video/animated GIFs.}
\begin{listing}[!htb]
\begin{minted}{C}
// Called for each frame rendered from 'ncv'. If anything but 0 is returned, the streaming operation
// ceases immediately, and that value is propagated out.
typedef int (*streamcb)(struct notcurses* nc, struct ncvisual* ncv, void*);

// Shut up and display my frames! Provide as an argument to ncvisual_stream(). If you'd like subtitles to
// be decoded, provide an ncplane as the curry. If the curry is NULL, subtitles will not be displayed.
static inline int ncvisual_simple_streamer(struct notcurses* nc, struct ncvisual* ncv, void* curry){
  if(notcurses_render(nc)){
    return -1;
  }
  int ret = 0;
  if(curry){
    // need a cast for C++ callers
    struct ncplane* subncp = (struct ncplane*)curry;
    char* subtitle = ncvisual_subtitle(ncv);
    if(subtitle){
      if(ncplane_putstr_yx(subncp, 0, 0, subtitle) < 0){
        ret = -1;
      }
      free(subtitle);
    }
  }
  return ret;
}
\end{minted}
\caption{\texttt{streamcb} callback type and \texttt{ncvisual\_simple\_streamer()}.}
\label{list:streamingcb}
\end{listing}

Running the loop discussed above is good for the soul, but usually it's
sufficient to let Notcurses handle things, perhaps with a callback to your
program. The function \texttt{ncvisual\_stream()} (Listing~\ref{list:streaming})
does just that, honoring the timing hints embedded in the stream as best it can.
Use of this function is strongly recommended. For the simplest use, \texttt{ncvisual\_simple\_streamer()}
(Listing~\ref{list:streamingcb}) can be provided as the callback. It will print
subtitles in the upper left, and otherwise render frames as it receives them.
If you require more complex per-frame activity, provide your own callback of
type \texttt{streamcb}, which can carry a \texttt{void*} curry.

\begin{listing}[!htb]
\begin{minted}{C}
// Stream the entirety of the media, according to its own timing. Blocking, obviously. streamer may be NULL;
// it is otherwise called for each frame, and its return value handled as outlined for stream cb. If
// streamer() returns non-zero, the stream is aborted, and that value is returned. By convention, return a
// positive number to indicate intentional abort from within streamer(). 'timescale' allows the frame
// duration time to be scaled. For a visual naturally running at 30FPS, a 'timescale' of 0.1 will result in
// 300FPS, and a 'timescale' of 10 will result in 3FPS. It is an error to supply 'timescale' less than or
// equal to 0.
int ncvisual_stream(struct notcurses* nc, struct ncvisual* ncv, int* averr,
                    float timescale, streamcb streamer, void* curry);
\end{minted}
\caption{Media streaming and \texttt{ncvisual\_simple\_streamer()}.}
\label{list:streaming}
\end{listing}

\subsection{Scaling images and video}
\begin{listing}[!htb]
\begin{minted}{C}
// How to scale the visual in ncvisual_from_file(). NCSCALE_NONE will open a plane tailored to the visual's
// exact needs, which is probably larger than the visible screen (but might be smaller). NCSCALE_SCALE
// scales a visual larger than the visible screen down, maintaining aspect ratio. NCSCALE_STRETCH stretches
// and scales the image in an attempt to fill the visible screen.
typedef enum { NCSCALE_NONE, NCSCALE_SCALE, NCSCALE_STRETCH, } ncscale_e;

// Open a visual, extract a codec and parameters, and create a new plane suitable for its display at 'y','x'.
// If there is sufficient room to display the visual in its native size, or if NCSCALE_NONE is passed for
// 'style', the new plane will be exactly that large. Otherwise, the plane will be as large as possible (given
// the visible screen), either maintaining aspect ratio (NCSCALE_SCALE) or abandoning it (NCSCALE_STRETCH).
struct ncvisual* ncvisual_from_file(struct notcurses* nc, const char* file, int* averr, int y, int x, ncscale_e style);
\end{minted}
\caption{Scaling media onto a new plane.}
\label{list:scaling}
\end{listing}
Notcurses relies on FFmpeg for all scaling, and thus must tell it the size of
the rendering area. An \texttt{ncvisual} is always scaled according to the
geometry of its associated plane's entirety. The scaling target is twice the
rendering target's height in rows, and equal to the rendering target's width in
columns. If the media is smaller than this, it will be scaled up. If larger, it
will be scaled down. A lossless representation thus requires rendering to a
plane having exactly half the media's height, and its exact width. Since it's
not generally possible to know the media's size until it's been partially
decoded, Notcurses provides \texttt{ncvisual\_open\_plane()}, which creates
a new plane based on the media's dimensions (this plane can be retrieved from
the returned \texttt{ncvisual} using \texttt{ncvisual\_plane()}). For an
exactly-matched plane, supply \texttt{NCSCALE\_NONE} (this plane might of course
be bigger or smaller than the viewing area). Use \texttt{NCSCALE\_STRETCH} to
scale the image to the rendering area (just like \texttt{ncplane\_visual\_open()},
except with a new plane). \texttt{NCSCALE\_SCALE} is not yet implemented, but
will retain media aspect ratio whilst scaling to fit at least one dimension
of the rendering area.

If the plane on which your \texttt{ncvisual} is to be rendered is larger than
the rendering area, you can save time by rendering only a portion of the
decoded image. \texttt{ncvisual\_render()} accepts four arguments specifying a
rectangular subsection via origin and dimensions. The last two arguments can be
specified as -1 to render through the end of the decoded frame. This is used
in the \texttt{eagle} demo to progressively ``zoom'' in on a level map much
larger than a typical terminal; in general, this will be the most efficient means
of effecting parallax scrolling.

\subsection{Sprites}
Danny Hillis is probably best known to computer architects for Thinking Machines,
but to the great video game-playing masses, it was his coinage of the term
``sprite'' which will be remembered (or not)\cite{tms34010}. First used in
conjunction with the hallowed TMS34010 of Texas Instruments, sprites are simply
bitmaps composed into a larger scene; like the French \textit{esprit} or Celtic
\textit{spriggan}\footnote{Both derived from the Latin \textit{spiritus}.}, they
float ethereally above the ground (plane). Notcurses supports full-sized sprites
via the combination of transparency and independently moved planes, often
populated via an external image file (texture).

The basic recipe for a sprite is:
\begin{denseitemize}
\item{Create a new plane above whatever background is in use.}
\item{Set the base character of this plane transparent.}
\item{Draw your object, possibly via \texttt{ncvisual\_render()}.}
\end{denseitemize}
The new plane can be moved freely, and the base transparency will allow the
underlying background to show through wherever you haven't drawn. The plane can
be as large as is convenient, so long as it's transparent everywhere the
sprite isn't present. To test whether the sprite has been ``hit'', the plane
itself can be used as a bounding box, but much better accuracy can be had by
testing the plane for character presence with \texttt{ncplane\_at\_yx()}.

If your sprite has an animation cycle---common for e.g. walking figures---it
can often be easiest to render each frame of the cycle to a distinct plane,
and keep only one visible at a time. This is used in the \texttt{luigi} demo
for Luigi's running cycle.

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{input}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{UI widgets}
Widgets provide ready-made tools for acquiring user input or displaying data.
As of Notcurses 1.2.4, there are four widgets: selector, multiselector, menu,
and reel. Multiple widgets can be in use at one time, and they are drawn onto
planes like any other output. Widgets can thus be moved up and down the z-axis.
It is not recommended to scribble on widgets, but nothing prevents you from
doing so. See Chapter~\ref{sec:input} for information about routing input to
widgets.

\label{sec:uiwidgets}
\subsection{Selectors and multiselectors}

The selector widget is an ncplane with a body section and optional title riser.
The body section is populated with options and descriptions, and supports
infinite scrolling up and down. The widget is automatically sized according to
the largest input provided. The keyboard and mouse wheel can scroll through
selections, and clicking on the arrows also scrolls. Selection and cancellation
are implemented by the caller. The currently-selected option can be retrieved
at any time. Option/description pairs can be added or removed while the
widget is active, even if the removed pair is currently selected. Removing the
last pair does not destroy the widget, and it is possible to create the widget
with no pairs.

\begin{figure}[!htb]
  \centering \includegraphics[width=.75\linewidth]{media/selector5.png}
  \caption{Naked selector.}
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=.75\linewidth]{media/selector1.png}
    \caption{Selector with a long title.}
\end{figure}

\begin{listing}[!htb]
\begin{minted}{C}
struct selector_item {
  char* option;
  char* desc;
};

typedef struct selector_options {
  char* title; // title may be NULL, inhibiting riser, saving two rows.
  char* secondary; // secondary may be NULL
  char* footer; // footer may be NULL
  struct selector_item* items; // initial items and descriptions
  unsigned itemcount; // number of initial items and descriptions
  // default item (selected at start), must be < itemcount unless 'itemcount'
  // is 0, in which case 'defidx' must also be 0
  unsigned defidx;
  // maximum number of options to display at once, 0 to use all available space
  unsigned maxdisplay;
  // exhaustive styling options
  uint64_t opchannels;   // option channels
  uint64_t descchannels; // description channels
  uint64_t titlechannels;// title channels
  uint64_t footchannels; // secondary and footer channels
  uint64_t boxchannels;  // border channels
  uint64_t bgchannels;   // background channels, used only in body
} selector_options;

struct ncselector* ncselector_create(struct ncplane* n, int y, int x, const selector_options* opts);
\end{minted}
\caption{Selector creation.}
\end{listing}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=.75\linewidth]{media/selector2.png}
    \caption{Short title intersecting with header.}
\end{figure}

\begin{figure}[!htb]
  \centering \includegraphics[width=.75\linewidth]{media/selector3.png}
    \caption{Selector with a long header.}
\end{figure}

\begin{figure}[!htb]
\centering \includegraphics[width=.75\linewidth]{media/selector4.png}
\caption{Selector with a long footer and no header.}
\end{figure}

\begin{listing}[!htb]
\begin{minted}{C}
int ncselector_additem(struct ncselector* n, const struct selector_item* item);
int ncselector_delitem(struct ncselector* n, const char* item);

// Return a reference to the selected option, or NULL if there are no items.
const char* ncselector_selected(const struct ncselector* n);

// Return a reference to the ncselector's underlying ncplane.
struct ncplane* ncselector_plane(struct ncselector* n);

// Move up or down in the list. A reference to the newly-selected item is
// returned, or NULL if there are no items in the list.
const char* ncselector_previtem(struct ncselector* n);
const char* ncselector_nextitem(struct ncselector* n);

// Offer the input to the ncselector. If it's relevant, this function returns
// true, and the input ought not be processed further. If it's irrelevant to
// the selector, false is returned. Relevant inputs include:
//  * a mouse click on an item
//  * a mouse scrollwheel event
//  * a mouse click on the scrolling arrows
//  * a mouse click outside of an unrolled menu (the menu is rolled up)
//  * up, down, pgup, or pgdown on an unrolled menu (navigates among items)
bool ncselector_offer_input(struct ncselector* n, const struct ncinput* nc);

// Destroy the ncselector. If 'item' is not NULL, the last selected option will
// be strdup()ed and assigned to '*item' (and must be free()d by the caller).
void ncselector_destroy(struct ncselector* n, char** item);
\end{minted}
\caption{Selector control.}
\end{listing}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{media/multiselector.png}
    \caption{Multiselector.}
\end{figure}

\subsection{Menus}
\label{sec:menus}
\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/menutop.png}
    \caption{Menu along the top of the standard plane.}
\end{figure}
Horizontal menu bars are supported on the top and bottom rows of planes. If a
menu bar is longer than the bound plane, it will be only partially visible, but
any unrolled section will be visible. Menus may be either visible or invisible
by default. Set the `hiding` option to get an invisible menu. In the event of a
screen resize, menus will be automatically moved/resized.

Listing~\ref{list:menucreate} covers creation of menus, and Listing~\ref{list:menucontrol}
covers their control.

\begin{listing}[!htb]
\begin{minted}{C}
typedef struct menu_options {
  bool bottom;              // on the bottom row, as opposed to top row
  bool hiding;              // hide the menu when not being used
  struct {
    char* name;             // utf-8 c string
    struct {
      char* desc;           // utf-8 menu item, NULL for horizontal separator
      ncinput shortcut;     // shortcut, all should be distinct
    }* items;
    int itemcount;
  }* sections;              // array of menu sections
  int sectioncount;         // must be positive
  uint64_t headerchannels;  // styling for header
  uint64_t sectionchannels; // styling for sections
} menu_options;

struct ncmenu;

// Create a menu with the specified options. Menus are currently bound to an overall notcurses object
// (as opposed to a particular plane), and are implemented as ncplanes kept atop other ncplanes.
struct ncmenu* ncmenu_create(struct notcurses* nc, const menu_options* opts);
\end{minted}
\caption{Menu creation.}
\label{list:menucreate}
\end{listing}

\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/menubottom.png}
    \caption{Menu along the bottom of the standard plane.}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/menuwarmech.png}
    \caption[WarMECH and a translucent menu.]{The \texttt{notcurses-demo} menu, unrolled \textit{in media res}. Luigi, pursued
      by WarMECH, is leaping through the ``Help'' menu. In the upper left is the HUD,
      and at the bottom the About text, both implemented as translucent planes.}
\end{figure}

\begin{listing}[!htb]
\begin{minted}{C}
// Unroll the specified menu section, making the menu visible if it was invisible, and rolling
// up any menu section that is already unrolled.
int ncmenu_unroll(struct ncmenu* n, int sectionidx);

// Roll up any unrolled menu section, and hide the menu if using hiding.
int ncmenu_rollup(struct ncmenu* n);

// Return the selected item description, or NULL if no section is unrolled. If 'ni' is not NULL,
// and the selected item has a shortcut, 'ni' will be filled in with that shortcut. This can allow faster matching.
const char* ncmenu_selected(const struct ncmenu* n, struct ncinput* ni);

// Return the ncplane backing this ncmenu.
struct ncplane* ncmenu_plane(struct ncmenu* n);

// Offer the input to the ncmenu. If it's relevant, this function returns true, and the input ought not be
// processed further. If it's irrelevant to the menu, false is returned. Relevant inputs include:
//  * mouse movement over a hidden menu
//  * a mouse click on a menu section (the section is unrolled)
//  * a mouse click outside of an unrolled menu (the menu is rolled up)
//  * left or right on an unrolled menu (navigates among sections)
//  * up or down on an unrolled menu (navigates among items)
//  * escape on an unrolled menu (the menu is rolled up)
bool ncmenu_offer_input(struct ncmenu* n, const struct ncinput* nc);

// Destroy a menu created with ncmenu_create().
int ncmenu_destroy(struct ncmenu* n);
\end{minted}
\caption{Menu control.}
\label{list:menucontrol}
\end{listing}

\subsection{Reels}
The ncreel\footnote{The term ``reel'' is borrowed from slot machines.} is a UI abstraction supported by Notcurses in which
dynamically-created and -destroyed toplevel entities (referred to as tablets)
are arranged on a ``cylinder'', allowing for infinite scrolling
(infinite scrolling can be disabled, resulting in a rectangle rather than a
cylinder). This works naturally with keyboard navigation, mouse scrolling wheels,
and touchpads (including the capacitive touchscreens of modern cell phones).
An ncreel initially has no tablets; at any given time thereafter, it has zero
or more tablets, and if there is at least one tablet, one tablet is focused
(and on-screen). If the last tablet is removed, no tablet is focused. A tablet
can support navigation within the tablet, in which case there is an in-tablet
focus for the focused tablet, which can also move among elements within the
tablet. Reels have a \texttt{struct ncreel\_options} object, passed to
\texttt{ncreel\_create()}; this struct is detailed in Listing~\ref{listing:reelopts}.

\begin{listing}[!htb]
\begin{minted}{C}
typedef struct ncreel_options {
  // require this many rows and columns (including borders). otherwise, a message will be displayed stating
  // that a larger terminal is necessary, and input will be queued. if 0, no minimum will be enforced. may
  // not be negative. note that ncreel_create() does not return error if given a plane smaller than these
  // minima; it instead patiently waits for the screen to get bigger.
  int min_supported_cols;
  int min_supported_rows;

  // use no more than this many rows and columns (including borders). may not be less than the
  // corresponding minimum. 0 means no maximum.
  int max_supported_cols;
  int max_supported_rows;

  // desired offsets within the surrounding WINDOW (top right bottom left) upon creation / resize. an
  // ncreel_move() operation updates these.
  int toff, roff, boff, loff;
  // is scrolling infinite (can one move down or up forever, or is an end reached?). if true, 'circular'
  // specifies how to handle the special case of an incompletely-filled reel.
  bool infinitescroll;
  // is navigation circular (does moving down from the last tablet move to the first, and vice versa)?
  // only meaningful when infinitescroll is true. if infinitescroll is false, this must be false.
  bool circular;
  // notcurses can draw a border around the ncreel, and also around the component tablets. inhibit
  // borders by setting all valid bits in the masks. partially inhibit borders by setting individual
  // bits in the masks. the appropriate attr and pair values will be used to style the borders. focused
  // and non-focused tablets can have different styles. you can instead draw your own borders, or
  // forgo borders entirely.
  unsigned bordermask; // bitfield; 1s will not be drawn (see bordermaskbits)
  uint64_t borderchan; // attributes used for ncreel border
  unsigned tabletmask; // bitfield; same as bordermask but for tablet borders
  uint64_t tabletchan; // tablet border styling channel
  uint64_t focusedchan;// focused tablet border styling channel
  uint64_t bgchannel;  // background colors
} ncreel_options;

struct ncreel;

// Create an ncreel according to the provided specifications. Returns NULL on failure. 'nc' must be a
// valid plane, to which offsets are relative. Note that there might not be enough room for the
// specified offsets, in which case the ncreel will be clipped on the bottom and right. A minimum number
// of rows and columns can be enforced via popts. efd, if non-negative, is an eventfd/pipe that ought be
// written to whenever ncreel_touch() updates a tablet (this is useful in the case of nonblocking input).
struct ncreel* ncreel_create(struct ncplane* nc, const ncreel_options* popts, int efd);
\end{minted}
\caption{Reel creation.}
\label{listing:reelopts}
\end{listing}

\begin{figure}
  \centering
  \includegraphics[width=.75\linewidth]{media/growlight1.png}
  \caption{\texttt{growlight}, a program built around reels.}
  \label{fig:growlight1}
\end{figure}

The ncreel object tracks the size, number, information depth, and order of
tablets, and the foci. It also draws the optional borders around tablets and
the optional border of the reel itself. It knows nothing about the actual
content of a tablet, save the number of lines it occupies at each information
depth. The typical control flow is that an application receives events (from
the UI or other event sources), and calls \texttt{ncreel\_touch()} on tablets
needing updates\footnote{This is one of the rare functions which can be called
concurrently with \texttt{notcurses\_render()}.}. Eventually, the application
calls \texttt{ncreel\_redraw()} to update the reel in its
entirety\footnote{A call to \texttt{notcurses\_render()} is still required to
update the display.}. Notcurses will call into the application for some number
of tablets, asking it to draw some line(s) from some tablet(s) at some
particular coordinate of that tablet's panel. Finally, control returns to the
application, and the cycle starts anew. The typedef for these callbacks is
defined in Listing~\ref{list:tabletcb}.

\begin{listing}[!htb]
\begin{minted}{C}
// Tablet draw callback, provided a tablet (from which the ncplane and userptr may be extracted),
// the first column that may be used, the first row that may be used, the first column that may not
// be used, the first row that may not be used, and a bool indicating whether output ought be
// clipped at the top (true) or bottom (false). Rows and columns are zero-indexed, and both are
// relative to the tablet's plane.
//
// Regarding clipping: it is possible that the tablet is only partially displayed on the screen. If
// so, it is either partially present on the top of the screen, or partially present at the bottom.
// In the former case, the top is clipped (cliptop will be true), and output ought start from the
// end. In the latter case, cliptop is false, and output ought start from the beginning.
//
// Returns the number of lines of output, which ought be less than or equal to
// maxy - begy, and non-negative (negative values might be used in the future).
typedef int (*tabletcb)(struct nctablet* t, int begx, int begy, int maxx, int maxy, bool cliptop);
\end{minted}
\caption{Tablet redraw callback function type.}
\label{list:tabletcb}
\end{listing}

Each tablet might be wholly, partially, or not on-screen. Notcurses always
places as much of the focused tablet as is possible on-screen (if the focused
tablet has more lines than the actual reel does, it cannot be wholly on-screen.
In this case, the focused subelements of the tablet are always on-screen). The
placement of the focused tablet depends on how it was reached (when moving to
the next tablet, offscreen tablets are brought onscreen at the bottom. When
moving to the previous tablet, offscreen tablets are brought onscreen at the
top. When moving to an arbitrary tablet which is neither the next nor previous
tablet, it will be placed in the center). Further ncreel functionality is detailed
in Listing~\ref{listing:reelcontrol}.

\begin{listing}[!htb]
\begin{minted}{C}
// Returns the ncplane on which this ncreel lives.
struct ncplane* ncreel_plane(struct ncreel* pr);

// Add a new tablet to the provided ncreel, having the callback object opaque. Neither, either, or both of
// after and before may be specified. If neither is specified, the new tablet can be added anywhere on the
// reel. If one or the other is specified, the tablet will be added before or after the specified tablet.
// If both are specified, the tablet will be added to the resulting location, assuming it is valid
// (after->next == before->prev); if it is not valid, or there is any other error, NULL will be returned.
struct nctablet* ncreel_add(struct ncreel* pr, struct nctablet* after, struct nctablet* before, tabletcb cb, void* opaque);

// Return the number of tablets.
int ncreel_tabletcount(const struct ncreel* pr);

// Indicate that the specified tablet has been updated in a way that would change its display.
// This will trigger some non-negative number of callbacks (though not in the caller's context).
int ncreel_touch(struct ncreel* pr, struct nctablet* t);

// Delete the tablet specified by t from the ncreel specified by pr. Returns -1 if the tablet cannot be found.
int ncreel_del(struct ncreel* pr, struct nctablet* t);

// Delete the active tablet. Returns -1 if there are no tablets.
int ncreel_del_focused(struct ncreel* pr);

// Move to the specified location within the containing plane.
int ncreel_move(struct ncreel* pr, int x, int y);

// Redraw the ncreel in its entirety, for instance after
// clearing the screen due to external corruption, or a SIGWINCH.
int ncreel_redraw(struct ncreel* pr);

// Return the focused tablet, if any tablets are present. This is not a copy;
// be careful to use it only for the duration of a critical section.
struct nctablet* ncreel_focused(struct ncreel* pr);

// Change focus to the next tablet, if one exists
struct nctablet* ncreel_next(struct ncreel* pr);

// Change focus to the previous tablet, if one exists
struct nctablet* ncreel_prev(struct ncreel* pr);

// Destroy an ncreel allocated with ncreel_create(). Does not destroy the
// underlying plane. Returns non-zero on failure.
int ncreel_destroy(struct ncreel* pr);

// Returns a pointer to a user pointer associated with this nctablet.
void* nctablet_userptr(struct nctablet* t);

// Access the ncplane associated with this tablet, if one exists.
struct ncplane* nctablet_ncplane(struct nctablet* t);
\end{minted}
\caption{Reel control.}
\label{listing:reelcontrol}
\end{listing}

Several widgets will probably be added, possibly before Notcurses 2.0:
\begin{denseitemize}
\item{A libreadline wrapper, or equivalent functionality.}
\item{Histogram and line plot capabilities using block elements and Braille.}
\item{A HUD for direct mode.}
\end{denseitemize}

\subsection{Example: let's rip off \texttt{whiptail}}
The \texttt{colloquy} program shipped with Notcurses implements a command-line
API similar to that of the Newt program \texttt{whiptail}, which itself ripped
off the NCURSES program \texttt{dialog}. All of these programs allow simple
user interfaces to be thrown up on the command line. \texttt{colloquy} is
written in Rust\footnote{\url{https://lib.rs/crates/colloquy}}, using the
Notcurses crate\footnote{\url{https://lib.rs/crates/notcurses}}, itself a wrapper
of the libnotcurses-sys\footnote{\url{https://lib.rs/crates/libnotcurses-sys}}
\texttt{bindgen}-generated Rust wrappers.

\section{Complex examples}
\subsection{Example: walking through \texttt{notcurses-demo}}
\label{sec:ncdemo}
The \texttt{notcurses-demo} program is built as part of Notcurses, and ought
have been installed alongside the library (on Debian, you'll need the
\texttt{notcurses-bin} package, and even then the demo has been somewhat
reduced in order to comply with the DFSG\cite{dfsg}). It demonstrates a wide
range of Notcurses capabilities, and its source code is most instructive.

It is best to run the demo in a terminal having geometry of at least 80x45,
though anything 80x24 or larger will more or less work (some content will be
clipped). It is also desirable to have 24-bit color enabled, assuming your
terminal supports it. Determine the number of colors advertised by your
terminal type using~\texttt{infocmp} (see Figure~\ref{fig:terminfocmp}).
Some relevant terminfo capabilities are described in Table~\ref{table:terminfo}.

\begin{table}[h]
  \begin{center}
    \begin{tabular}{ |c|c|c| }
      \hline
      \texttt{colors} & Integer & Number of colors. \\
      \hline
      \texttt{ccc} & Boolean & The palette can be programmed. \\
      \hline
      \texttt{RGB} & Boolean & Direct RGB values can be specified. \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Relevant terminfo properties.}
  \label{table:terminfo}
\end{table}

Each demo makes use of a few different Notcurses capabilities. In addition,
a menu is present throughout. From this menu (or using keyboard shortcuts),
you can activate a HUD (H) and an informational help display (Ctrl+u). In
addition, you can restart the demo with Ctrl+R, or quit at any time (q). This
application serves admirably for benchmarking certain terminal behaviors, and
we'll do exactly that in Appendix~\ref{sec:termshade}. The performance
properties of various components are described at length therein.

\begin{figure}[h]
  \centering
  \includegraphics[width=.75\linewidth]{media/terminfocmp.png}
  \caption{Inspecting the terminfo database.}
  \label{fig:terminfocmp}
\end{figure}

Screenshots were taken using \texttt{scrot} 1.2 and a 80x45
\texttt{xfce4-terminal} 0.8.9.1 from Xfce 4.14+Compiz 0.8.16.1 atop Xorg
1.20.7 on NVIDIA 440.59. All of these are the unmodified Debian Unstable
x86\_64 binaries. My kernel is a custom 5.5.6 build. The terminal type is
\texttt{vte-256color}, and \texttt{COLORTERM} is defined to be
\texttt{24bit}. The terminal font was Hack 10, and the background is a 0.7
transparency.

\cleardoublepage

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-intro.png}
    \caption[``Intro''.]{``Intro''. Lerps on the perimeters. Inverse radial
            gradient plus vertical gradient. Full-screen fade.
            Cyclic glyphs. Italics.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-xray.png}
    \caption[``X-Ray''. Very large planes.]{``X-Ray''. Streaming video.
       Very large planes (the scrolling plane at the bottom is much larger than the visible screen).}
  \end{minipage}
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demoeagle2.png}
    \caption{``Eagle'', first phase.\\
      Parallax scrolling on large image.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demoeagle1.png}
    \caption{``Eagle'', second phase.\\
      Sprites. Zoomed image.}
  \end{minipage}
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.30\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-trans1.png}
    \caption[``Trans'', early phase.]{``Trans''. Transparent top plane. Window through to the desktop.}
  \end{minipage}\hfill
  \begin{minipage}{0.30\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-trans2.png}
    \caption[``Trans'', middle phase.]{``Trans''. Opaque foreground, transparent background, no glyph.}
  \end{minipage}\hfill
  \begin{minipage}{0.30\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-trans3.png}
    \caption[``Trans'', late phase.]{``Trans''. Transparent foreground and background with opaque glyph.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-highcon.png}
    \caption{``Highcon''. High-contrast text.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-grid.png}
    \caption{``Grid''. Max RGB density.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-box.png}
    \caption{``Box''. Lerped perimeters. Precise Unicode. Color sweeps.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-sliders.png}
    \caption{``Sliders''. Partial fades. Animation. Gradients.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-reels.png}
    \caption{``Reels''. The \texttt{ncreel} widget.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-whiteout.png}
    \caption{``Whiteout''. Translucency.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering \includegraphics[width=.65\linewidth]{media/demo-chunli1.png}
  \caption{``Chunli''. Sprite animation.}
\end{figure}

\begin{figure}
  \centering \includegraphics[width=.65\linewidth]{media/demo-chunli2.png}
  \caption{``Chunli''. Sprite animation.}
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-uniblock1.png}
    \caption{``Uniblock''. Hangul syllables.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-uniblock2.png}
    \caption{``Uniblock''. Emoji.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-img1.png}
    \caption{``View''. Scaling an image.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-img2.png}
    \caption{``View''. Transparent images.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-view1.png}
    \caption{``View''. Streaming video with high-contrast text.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-view2.png}
    \caption{``View''. Notice the high-contrast kicking in.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering \includegraphics[width=1\linewidth]{media/demojungle.png}
  \caption[``Jungle''. Palette-indexed image.]{``Jungle''. Palette-indexed image. Very low-bandwidth animation via palette cycling.\\
    ``Ruins in Rain'' © Mark Ferrari/Living Worlds. Texelized with permission.}
\end{figure}


\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-fallin1.png}
    \caption[``Fallin\''', early phase.]{``Fallin\'''. Color change, introspection, many planes.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-fallin2.png}
    \caption[``Fallin\''', late phase.]{``Fallin\'''. The underlying image is revealed.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-luigi.png}
    \caption{``Luigi''. Multiple sprites.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-outro.png}
    \caption{``Outro''. Fades atop video.}
  \end{minipage}\hfill
\end{figure}

\pagebreak
\cleardoublepage

\input{tetris}
\pagebreak
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{appendices}

\input{termhistory.tex}
\pagebreak
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{benchmarks.tex}
\pagebreak
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Linux console}
The Linux console\footnote{The FreeBSD console is its own bag of wonders.} is
substantially different from the X and Wayland terminal emulators to which one
might be more accustomed\footnote{Muddying the issue is the fact that video
backends are sometimes described as consoles. The ``Linux console'' is a terminal
emulator running atop some video backend---on the x86, typically either VGA
Text Mode, or some trivial renderer atop a graphics-mode framebuffer
(e.\ g.\ EFIfb or vesafb.)}. Modern terminal emulators are generally more capable
than the Linux console in several ways:

\begin{denseitemize}
\item{While the Linux console accepts RGB specifiers, it downsamples them to
    far fewer colors.}
\item{Console font capabilities are extremely limited.}
\end{denseitemize}

Userspace alternatives to the Linux console include \texttt{fbterm} and
\texttt{kmscon}.

Like any interface to a termios\cite{termios} implementation, the \texttt{IUTF8}
flag should be set (consult \texttt{stty}). This can be accomplished with the
\texttt{IUTF8} termios flag (or \texttt{stty iutf8} on the command line). This
is necessary for the terminal to interpret your output as multibyte UTF-8. The
keyboard driver ought be placed into UTF-8 mode using the \texttt{KDSKBMODE}
ioctl; the \texttt{kbd-mode} tool does this when invoked with \texttt{-u}.
This is necessary for character erase to function properly in cooked mode. Some
keyboards generate scancodes beyond the essential 128 characters, and these
should be mapped to their UTF-8 equivalents. This can be accomplished with
\texttt{dumpkeys | loadkeys --unicode}\footnote{If you've ever seen the script
\texttt{unicode\_start}, this is exactly what it does.}. This functionality has
been supported since Linux 2.6.4, released 2004-03-11, and is almost certainly
already being done in your environment.

Ensure, as always, that \texttt{LANG} is properly set, that your program
initializes the locale with \texttt{setlocale(3)}, and that \texttt{TERM} is
properly set (in this case, to one of the ``linux*'' variants).

The console font supports only 256 characters, or 512 when colors are cut in
half. The built-in ``PSF''\footnote{The PC Screen Font of H. Peter Anvin and
  Andries Brouwer.} font supports the 256 characters of CP437 (remember
CP437?). The font can be displayed with the \texttt{showconsolefont} command,
and updated with \texttt{setfont}. The font is independent of whether the
console is supplied via \texttt{vgacon} or e.g. \texttt{fbcon}. It is worth
noting that this default font is missing several characters of which Notcurses
makes extensive default use, particularly the rounded and double box-drawing
characters. I intend to look into reprogramming the console font on the fly to
better support this environment\footnote{See \url{https://github.com/dankamongmen/notcurses/issues/201}.},
but for the moment, Notcurses on the console is definitely a weak spot.

Consult the \textit{The Linux Programmer's Manual} for more information,
particularly
\texttt{ioctl\_console(2)}\cite{ioctlconsole},
\texttt{ioctl\_tty(2)}\cite{ioctltty},
\texttt{termios(3)}\cite{termios},
\texttt{console\_codes(4)}\cite{consolecodes},
and
\texttt{charsets(7)}\cite{charsets7}.

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Unicode 13}
The Unicode Consortium has scheduled Unicode 13.0 for a March 2020 release.
Chapters 3 and most of Chapter 4 of the Core Specification are normative. The
remainder is informative. The Unicode Standard consists of the Core
Specification\cite{unicode13}, the \href{https://www.unicode.org/charts/}{code charts},
the \href{https://unicode.org/versions/Unicode13.0.0/#Unicode_Standard_Annexes_nb}{Unicode Standard Annexes},
and the \href{http://www.unicode.org/Public/13.0.0/}{Unicode Character Database (UCD)}.

A Unicode Standard Annex (UAX) forms an integral part of the Unicode Standard,
but is published online as a separate document. The Unicode Standard may
require conformance to normative content in a Unicode Standard Annex, if so
specified in the Conformance chapter of that version of the Unicode Standard.
The version number of a UAX document corresponds to the version of the Unicode
Standard of which it forms a part.

\begin{table}[h]
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    UAX \#9 & Unicode Bidirectional Algorithm \\
    \hline
    UTS \#10 & Unicode Collation Algorithm \\
    \hline
    UAX \#11 & East Asian Width \\
    \hline
    UAX \#14 & Unicode Line Breaking Algorithm \\
    \hline
    UAX \#15 & Unicode Normalization Forms \\
    \hline
    UAX \#24 & Unicode Script Property \\
    \hline
    UAX \#29 & Unicode Text Segmentation \\
    \hline
    UAX \#31 & Unicode Identifier and Pattern Syntax \\
    \hline
    UAX \#34 & Unicode Named Character Sequences \\
    \hline
    UAX \#38 & Unicode Han Database (Unihan) \\
    \hline
    UTS \#39 & Unicode Security Mechanisms \\
    \hline
    UAX \#41 & Common References for Unicode Standard Annexes \\
    \hline
    UAX \#42 & Unicode Character Database in XML \\
    \hline
    UAX \#44 & Unicode Character Database \\
    \hline
    UAX \#45 & U-Source Ideographs \\
    \hline
    UTS \#46 & Unicode IDNA Compatibility Processing \\
    \hline
    UAX \#50 & Unicode Vertical Text Layout \\
    \hline
    UTS \#51 & Unicode Emoji \\
    \hline
  \end{tabular}
\caption{Unicode 13.0.0 Standard Annexes and Synchronized Technical Standards.}
\end{center}
\end{table}

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Relevant Standards}
All major standards regarding character sets, control sequences, and their
encoding have ISO/IEC versions, which should probably be considered their
canonical editions. Many of these ISO/IEC standards ratified or included ECMA
or ANSI standards. Table~\ref{table:standards} lists equivalencies.

\vspace{.5in}

\begin{table}[!h]
  \centering
  \begin{tabular}{|l|l|l|l|}
    \hline
    ISO/IEC & ANSI & ECMA & Topic \\
    \hline
    \hline
    646:1991 & X3.4-1986 & 6:1991 & \makecell[l]{7-bit character sets \\ Twinned with ITU T.50} \\
    \hline
    2022:1994 & x & 35:1994 & 8-bit character sets \\
    \hline
    2375:2003 & x & x & Registration of character sets \\
    \hline
    4873:1991 & x & 43:1991 & Multitiered 8-bit codes \\
    \hline
    6429:1992 & X3.64-1979 & 48:1991 & Control codes \\
    \hline
    8613-6:1994 & x & x & \makecell[l]{Graphic renditions in terms of SGR \\Twinned to ITU T.416} \\
    \hline
    8859:1998 & x & 94:1986 & \makecell[l]{Official 8-bit character sets\\ECMA 96 is only \textnumero 1 to \textnumero 4.} \\
    \hline
    10367:1991 & x & x & G0, G1, G2, and G3 \\
    \hline
    10646:2017 & x & x & The Universal Character Set \\
    \hline
    14755:1996 & x & x & Input methods for the UCS \\
    \hline
  \end{tabular}
  \caption{ECMA/ANSI/ISO standards referenced in this text.}
  \label{table:standards}
\end{table}

\vspace{.5in}

POSIX is a family of standards from IEEE 1003, first released as IEEE 1003.1-1988 as:
\begin{denseitemize}
\item{POSIX.1/IEEE 1003.1-1988: Core Services, incorporating ANSI C 1989}
\item{POSIX.2/IEEE 1003.2-1992: Shell and utilities}
\item{POSIX.1b/IEEE 1003.1b-1993: Real-time extensions}
\item{POSIX.1c/IEEE 1003.1c-1995: Threads}
\end{denseitemize}
Starting with the 1997's SUS2 (``UNIX 98''), it was agreed that the Austin
Group would take over development of POSIX. Releases of the standard would be
done under the SUS aegis, and then made POSIX standards upon ISO ratification.
Three releases have followed---POSIX.1-2001 and its amending 2004 Technical Corrigendae,
POSIX.1-2008 (aka ``Base Specifications Issue 7'') and \textit{its} two amendments,
and POSIX.1-2017.

The Single Unix Specification, then, is developed and issued by the Austin
Group, a combination of ISO JTC 1 SC22, the Open Group, and ISO 1003. The first
SUS emerged in 1995 as a ratification of the Open Group's Portability Guide (XPG)
4 version 2. SUS2 followed in 1997, as mentioned, and in 2001 came the glorious
unification: SUS3 aka POSIX.1-2001. SUS4 was built atop POSIX.1-2008, and has
seen three new editions in 2013, 2016, and 2018. If you comply with SUS4 including
both its Technical Corrigendae, you're officially ``UNIX V7'', and are out a few
tens of thousands of dollars in Open Group conformance testing.

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{Notcurses header files}
%\subsection{The \texttt{notcurses.h} header}
%\bgroup
%\inputminted[linenos,breaklines=true]{C}{code/notcurses.h}
%\egroup
%
%\subsection{The \texttt{nckeys.h} header}
%\bgroup
%\inputminted[linenos,breaklines=true]{C}{code/nckeys.h}
%\egroup

\end{appendices}
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\glsaddallunused
\printglossary[title={Glossary of terms}]
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\addcontentsline{toc}{section}{References}
\printbibliography
\phantomsection
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace*{.5in}
\addcontentsline{toc}{section}{Acknowledgments}
\begin{center}\textbf{Acknowledgments}\end{center}
Hail Eris! All Hail Discordia!

This work would not have been possible without the early customers of
Dirty South Supercomputing; thank you Jeff Arnold at ShareCare,
Todd Wilson at Vakaros, Charles Brian Quinn at Greenzie, Carl Ledbetter
at SimpleRose, Keshav Attrey at PureStorage, Jaron Nix at Pathware,
Miguel Turner at Cyxtera, and the folks who can't be mentioned. Keep
churning through DGEMMs and blowing shit up, everybody. Yacin Nadji,
Scott Hughes, Paige Bailey, Brendan Dolan-Gavitt, Brett W.\ Thompson, Bill
Phillips, Lee Hall, Jon Paprocki, and Joe Lafiosca were particularly supportive of the Notcurses
endeavor. Mark Ferrari let me use his mindblowing palette-cycling pixel art,
and was awfully sweet to a weird dude emailing him from out of nowhere. GitHub
has remained shockingly useful and unoffensive for a Microsoft product. Robert
Edmonds helped me get Notcurses into Debian's NEW queue, and coached me in the
ways of the DFSG. Marek Habersack wrote the \CC wrapper, and has kept it up to
date despite my total lack of communication or warning before lunging in
entirely new API directions. Where would I be without jwz? Astrid Bin did the
awesome DSSCAW logo\footnote{Minus the boss purple gradient, which I applied
  against her passionate wishes. I stand by my call.}, and I couldn't pay her
in the end due to bullshit laws---like, I drunkenly called her up and was like
``FUCK DA POLICE i'll drop a brown paper sack of \$10 bills on your porch and
steal you a social security number, arrrrrrrr'' and yet she refused---thanks,
Astrid! Mary Ann Horton, the original author of terminfo, was gracious and
helpful in her responses. Thomas E. Dickey, author/maintainer of many venerable
trees including NCURSES, is a saint and an angel, a UNESCO treasure, and the
very model of conservative, thoughtful software stewardship. He graciously
answered my mails with lengthy and rigorous information. The free software
community owes him a great debt.

Shouts out to Midtown Yuppie Scum (ATL) and Stinkeye of the Tiger (NYC) Trivia
Clubs. Shouts out to Paul Johnson and Paul Judge. Shouts out to Outkast, Goodie
Mob, and RTJ. Shouts out to every freedom-loving person around the world
fighting the unceasing struggle against International Communism. God save the
Constitution and God save the Republic.
\vfill
\begin{center}
\includegraphics[width=.4\linewidth]{../common/dsscaw-purp-scaled.png}
\includegraphics[width=.5\linewidth]{../common/south.png}
\end{center}
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace*{.5in}
\addcontentsline{toc}{section}{About the author}
\begin{center}\textbf{About the Author}\end{center}
Aside from adventures in New York and Austin, Nick Black is a lifelong ATLien.
He began programming on an ATARI 400 sometime during childhood, and with no one
around to tell him better, developed an idiosyncratic, unorthodox style
involving more inline assembly and literary allusions than strictly
necessary, or perhaps even justifiable. He has since graduated several times
from the Georgia Institute of Technology, and dropped out almost as many times.
Approaching forty, he still manages to code about ten hours a day, every day,
ideally those free of the Daystar's malignant influence. He hopes to one day
destroy the sun. This is his first book as an adult. He lives in Midtown
Atlanta with wife Emily (both a finer engineer, and just plain finer),
along with their poofy penguin and several orca. Nick exclusively uses black
IBM Model-M Trackpoint II M-13 keyboards, and will happily buy any that you
might have laying around \textbf{CLACK CLACK CLACK}.

\begin{figure}
  \centering
\includegraphics[width=.75\linewidth]{media/theauthor.jpg}
%\caption{The author in a bathroom somewhere.}
\end{figure}
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\includepdf{media/backcover.pdf}
\end{document}
